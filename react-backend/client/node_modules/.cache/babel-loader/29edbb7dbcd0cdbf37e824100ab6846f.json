{"ast":null,"code":"'use strict';\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar WritableTrackingBuffer = require('./tracking-buffer/writable-tracking-buffer');\n\nvar crypto = require('crypto');\n\nvar BigInteger = require('big-number').n;\n\nvar hex = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n\nvar NTLMResponsePayload = function () {\n  function NTLMResponsePayload(loginData) {\n    (0, _classCallCheck3.default)(this, NTLMResponsePayload);\n    this.data = this.createResponse(loginData);\n  }\n\n  (0, _createClass3.default)(NTLMResponsePayload, [{\n    key: 'toString',\n    value: function toString() {\n      var indent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      return indent + 'NTLM Auth';\n    }\n  }, {\n    key: 'createResponse',\n    value: function createResponse(challenge) {\n      var client_nonce = this.createClientNonce();\n      var lmv2len = 24;\n      var ntlmv2len = 16;\n      var domain = challenge.domain;\n      var username = challenge.userName;\n      var password = challenge.password;\n      var ntlmData = challenge.ntlmpacket;\n      var server_data = ntlmData.target;\n      var server_nonce = ntlmData.nonce;\n      var bufferLength = 64 + domain.length * 2 + username.length * 2 + lmv2len + ntlmv2len + 8 + 8 + 8 + 4 + server_data.length + 4;\n      var data = new WritableTrackingBuffer(bufferLength);\n      data.position = 0;\n      data.writeString(\"NTLMSSP\\0\", 'utf8');\n      data.writeUInt32LE(0x03);\n      var baseIdx = 64;\n      var dnIdx = baseIdx;\n      var unIdx = dnIdx + domain.length * 2;\n      var l2Idx = unIdx + username.length * 2;\n      var ntIdx = l2Idx + lmv2len;\n      data.writeUInt16LE(lmv2len);\n      data.writeUInt16LE(lmv2len);\n      data.writeUInt32LE(l2Idx);\n      data.writeUInt16LE(ntlmv2len);\n      data.writeUInt16LE(ntlmv2len);\n      data.writeUInt32LE(ntIdx);\n      data.writeUInt16LE(domain.length * 2);\n      data.writeUInt16LE(domain.length * 2);\n      data.writeUInt32LE(dnIdx);\n      data.writeUInt16LE(username.length * 2);\n      data.writeUInt16LE(username.length * 2);\n      data.writeUInt32LE(unIdx);\n      data.writeUInt16LE(0);\n      data.writeUInt16LE(0);\n      data.writeUInt32LE(baseIdx);\n      data.writeUInt16LE(0);\n      data.writeUInt16LE(0);\n      data.writeUInt32LE(baseIdx);\n      data.writeUInt16LE(0x8201);\n      data.writeUInt16LE(0x08);\n      data.writeString(domain, 'ucs2');\n      data.writeString(username, 'ucs2');\n      var lmv2Data = this.lmv2Response(domain, username, password, server_nonce, client_nonce);\n      data.copyFrom(lmv2Data);\n      var genTime = new Date().getTime();\n      ntlmData = this.ntlmv2Response(domain, username, password, server_nonce, server_data, client_nonce, genTime);\n      data.copyFrom(ntlmData);\n      data.writeUInt32LE(0x0101);\n      data.writeUInt32LE(0x0000);\n      var timestamp = this.createTimestamp(genTime);\n      data.copyFrom(timestamp);\n      data.copyFrom(client_nonce);\n      data.writeUInt32LE(0x0000);\n      data.copyFrom(server_data);\n      data.writeUInt32LE(0x0000);\n      return data.data;\n    }\n  }, {\n    key: 'createClientNonce',\n    value: function createClientNonce() {\n      var client_nonce = new Buffer(8).fill(0);\n      var nidx = 0;\n\n      while (nidx < 8) {\n        client_nonce.writeUInt8(Math.ceil(Math.random() * 255), nidx);\n        nidx++;\n      }\n\n      return client_nonce;\n    }\n  }, {\n    key: 'ntlmv2Response',\n    value: function ntlmv2Response(domain, user, password, serverNonce, targetInfo, clientNonce, mytime) {\n      var timestamp = this.createTimestamp(mytime);\n      var hash = this.ntv2Hash(domain, user, password);\n      var dataLength = 40 + targetInfo.length;\n      var data = new Buffer(dataLength).fill(0);\n      serverNonce.copy(data, 0, 0, 8);\n      data.writeUInt32LE(0x101, 8);\n      data.writeUInt32LE(0x0, 12);\n      timestamp.copy(data, 16, 0, 8);\n      clientNonce.copy(data, 24, 0, 8);\n      data.writeUInt32LE(0x0, 32);\n      targetInfo.copy(data, 36, 0, targetInfo.length);\n      data.writeUInt32LE(0x0, 36 + targetInfo.length);\n      return this.hmacMD5(data, hash);\n    }\n  }, {\n    key: 'createTimestamp',\n    value: function createTimestamp(time) {\n      var tenthsOfAMicrosecond = new BigInteger(time).plus(11644473600).multiply(10000000);\n      var hexArray = [];\n      var pair = [];\n\n      while (tenthsOfAMicrosecond.val() !== '0') {\n        var idx = tenthsOfAMicrosecond.mod(16);\n        pair.unshift(hex[idx]);\n\n        if (pair.length === 2) {\n          hexArray.push(pair.join(''));\n          pair = [];\n        }\n      }\n\n      if (pair.length > 0) {\n        hexArray.push(pair[0] + '0');\n      }\n\n      return new Buffer(hexArray.join(''), 'hex');\n    }\n  }, {\n    key: 'lmv2Response',\n    value: function lmv2Response(domain, user, password, serverNonce, clientNonce) {\n      var hash = this.ntv2Hash(domain, user, password);\n      var data = new Buffer(serverNonce.length + clientNonce.length).fill(0);\n      serverNonce.copy(data);\n      clientNonce.copy(data, serverNonce.length, 0, clientNonce.length);\n      var newhash = this.hmacMD5(data, hash);\n      var response = new Buffer(newhash.length + clientNonce.length).fill(0);\n      newhash.copy(response);\n      clientNonce.copy(response, newhash.length, 0, clientNonce.length);\n      return response;\n    }\n  }, {\n    key: 'ntv2Hash',\n    value: function ntv2Hash(domain, user, password) {\n      var hash = this.ntHash(password);\n      var identity = new Buffer(user.toUpperCase() + domain.toUpperCase(), 'ucs2');\n      return this.hmacMD5(identity, hash);\n    }\n  }, {\n    key: 'ntHash',\n    value: function ntHash(text) {\n      var hash = new Buffer(21).fill(0);\n      hash.fill(0);\n      var unicodeString = new Buffer(text, 'ucs2');\n      var md4 = crypto.createHash('md4').update(unicodeString).digest();\n\n      if (md4.copy) {\n        md4.copy(hash);\n      } else {\n        new Buffer(md4, 'ascii').copy(hash);\n      }\n\n      return hash;\n    }\n  }, {\n    key: 'hmacMD5',\n    value: function hmacMD5(data, key) {\n      var hmac = crypto.createHmac('MD5', key);\n      hmac.update(data);\n      var result = hmac.digest();\n\n      if (result.copy) {\n        return result;\n      } else {\n        return new Buffer(result, 'ascii').slice(0, 16);\n      }\n    }\n  }]);\n  return NTLMResponsePayload;\n}();\n\nmodule.exports = NTLMResponsePayload;","map":null,"metadata":{},"sourceType":"script"}