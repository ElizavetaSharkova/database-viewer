{"ast":null,"code":"'use strict';\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar bigint = require('./bigint');\n\nvar SHIFT_LEFT_32 = (1 << 16) * (1 << 16);\nvar SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;\nvar UNKNOWN_PLP_LEN = new Buffer([0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);\nvar ZERO_LENGTH_BUFFER = new Buffer(0);\n/*\n  A Buffer-like class that tracks position.\n\n  As values are written, the position advances by the size of the written data.\n  When writing, automatically allocates new buffers if there's not enough space.\n */\n\nmodule.exports = function () {\n  function WritableTrackingBuffer(initialSize, encoding, doubleSizeGrowth) {\n    (0, _classCallCheck3.default)(this, WritableTrackingBuffer);\n    this.initialSize = initialSize;\n    this.encoding = encoding || 'ucs2';\n    this.doubleSizeGrowth = doubleSizeGrowth || false;\n    this.buffer = new Buffer(this.initialSize).fill(0);\n    this.compositeBuffer = new Buffer(0);\n    this.position = 0;\n  } // $FlowFixMe: Flow does not like getter/setters that have side-effects.\n\n\n  (0, _createClass3.default)(WritableTrackingBuffer, [{\n    key: 'copyFrom',\n    value: function copyFrom(buffer) {\n      var length = buffer.length;\n      this.makeRoomFor(length);\n      buffer.copy(this.buffer, this.position);\n      this.position += length;\n    }\n  }, {\n    key: 'makeRoomFor',\n    value: function makeRoomFor(requiredLength) {\n      if (this.buffer.length - this.position < requiredLength) {\n        if (this.doubleSizeGrowth) {\n          var size = Math.max(128, this.buffer.length * 2);\n\n          while (size < requiredLength) {\n            size *= 2;\n          }\n\n          this.newBuffer(size);\n        } else {\n          this.newBuffer(requiredLength);\n        }\n      }\n    }\n  }, {\n    key: 'newBuffer',\n    value: function newBuffer(size) {\n      var buffer = this.buffer.slice(0, this.position);\n      this.compositeBuffer = Buffer.concat([this.compositeBuffer, buffer]);\n      this.buffer = size === 0 ? ZERO_LENGTH_BUFFER : new Buffer(size).fill(0);\n      this.position = 0;\n    }\n  }, {\n    key: 'writeUInt8',\n    value: function writeUInt8(value) {\n      var length = 1;\n      this.makeRoomFor(length);\n      this.buffer.writeUInt8(value, this.position);\n      this.position += length;\n    }\n  }, {\n    key: 'writeUInt16LE',\n    value: function writeUInt16LE(value) {\n      var length = 2;\n      this.makeRoomFor(length);\n      this.buffer.writeUInt16LE(value, this.position);\n      this.position += length;\n    }\n  }, {\n    key: 'writeUShort',\n    value: function writeUShort(value) {\n      this.writeUInt16LE(value);\n    }\n  }, {\n    key: 'writeUInt16BE',\n    value: function writeUInt16BE(value) {\n      var length = 2;\n      this.makeRoomFor(length);\n      this.buffer.writeUInt16BE(value, this.position);\n      this.position += length;\n    }\n  }, {\n    key: 'writeUInt24LE',\n    value: function writeUInt24LE(value) {\n      var length = 3;\n      this.makeRoomFor(length);\n      this.buffer[this.position + 2] = value >>> 16 & 0xff;\n      this.buffer[this.position + 1] = value >>> 8 & 0xff;\n      this.buffer[this.position] = value & 0xff;\n      this.position += length;\n    }\n  }, {\n    key: 'writeUInt32LE',\n    value: function writeUInt32LE(value) {\n      var length = 4;\n      this.makeRoomFor(length);\n      this.buffer.writeUInt32LE(value, this.position);\n      this.position += length;\n    }\n  }, {\n    key: 'writeInt64LE',\n    value: function writeInt64LE(value) {\n      var buf = bigint.numberToInt64LE(value);\n      this.copyFrom(buf);\n    }\n  }, {\n    key: 'writeUInt32BE',\n    value: function writeUInt32BE(value) {\n      var length = 4;\n      this.makeRoomFor(length);\n      this.buffer.writeUInt32BE(value, this.position);\n      this.position += length;\n    }\n  }, {\n    key: 'writeUInt40LE',\n    value: function writeUInt40LE(value) {\n      // inspired by https://github.com/dpw/node-buffer-more-ints\n      this.writeInt32LE(value & -1);\n      this.writeUInt8(Math.floor(value * SHIFT_RIGHT_32));\n    }\n  }, {\n    key: 'writeUInt64LE',\n    value: function writeUInt64LE(value) {\n      this.writeInt32LE(value & -1);\n      this.writeUInt32LE(Math.floor(value * SHIFT_RIGHT_32));\n    }\n  }, {\n    key: 'writeInt8',\n    value: function writeInt8(value) {\n      var length = 1;\n      this.makeRoomFor(length);\n      this.buffer.writeInt8(value, this.position);\n      this.position += length;\n    }\n  }, {\n    key: 'writeInt16LE',\n    value: function writeInt16LE(value) {\n      var length = 2;\n      this.makeRoomFor(length);\n      this.buffer.writeInt16LE(value, this.position);\n      this.position += length;\n    }\n  }, {\n    key: 'writeInt16BE',\n    value: function writeInt16BE(value) {\n      var length = 2;\n      this.makeRoomFor(length);\n      this.buffer.writeInt16BE(value, this.position);\n      this.position += length;\n    }\n  }, {\n    key: 'writeInt32LE',\n    value: function writeInt32LE(value) {\n      var length = 4;\n      this.makeRoomFor(length);\n      this.buffer.writeInt32LE(value, this.position);\n      this.position += length;\n    }\n  }, {\n    key: 'writeInt32BE',\n    value: function writeInt32BE(value) {\n      var length = 4;\n      this.makeRoomFor(length);\n      this.buffer.writeInt32BE(value, this.position);\n      this.position += length;\n    }\n  }, {\n    key: 'writeFloatLE',\n    value: function writeFloatLE(value) {\n      var length = 4;\n      this.makeRoomFor(length);\n      this.buffer.writeFloatLE(value, this.position);\n      this.position += length;\n    }\n  }, {\n    key: 'writeDoubleLE',\n    value: function writeDoubleLE(value) {\n      var length = 8;\n      this.makeRoomFor(length);\n      this.buffer.writeDoubleLE(value, this.position);\n      this.position += length;\n    }\n  }, {\n    key: 'writeString',\n    value: function writeString(value, encoding) {\n      if (encoding == undefined) {\n        encoding = this.encoding;\n      }\n\n      var length = Buffer.byteLength(value, encoding);\n      this.makeRoomFor(length); // $FlowFixMe https://github.com/facebook/flow/pull/5398\n\n      this.buffer.write(value, this.position, encoding);\n      this.position += length;\n    }\n  }, {\n    key: 'writeBVarchar',\n    value: function writeBVarchar(value, encoding) {\n      this.writeUInt8(value.length);\n      this.writeString(value, encoding);\n    }\n  }, {\n    key: 'writeUsVarchar',\n    value: function writeUsVarchar(value, encoding) {\n      this.writeUInt16LE(value.length);\n      this.writeString(value, encoding);\n    } // TODO: Figure out what types are passed in other than `Buffer`\n\n  }, {\n    key: 'writeUsVarbyte',\n    value: function writeUsVarbyte(value, encoding) {\n      if (encoding == undefined) {\n        encoding = this.encoding;\n      }\n\n      var length = void 0;\n\n      if (value instanceof Buffer) {\n        length = value.length;\n      } else {\n        value = value.toString();\n        length = Buffer.byteLength(value, encoding);\n      }\n\n      this.writeUInt16LE(length);\n\n      if (value instanceof Buffer) {\n        this.writeBuffer(value);\n      } else {\n        this.makeRoomFor(length); // $FlowFixMe https://github.com/facebook/flow/pull/5398\n\n        this.buffer.write(value, this.position, encoding);\n        this.position += length;\n      }\n    }\n  }, {\n    key: 'writePLPBody',\n    value: function writePLPBody(value, encoding) {\n      if (encoding == null) {\n        encoding = this.encoding;\n      }\n\n      var length = void 0;\n\n      if (value instanceof Buffer) {\n        length = value.length;\n      } else {\n        value = value.toString();\n        length = Buffer.byteLength(value, encoding);\n      } // Length of all chunks.\n      // this.writeUInt64LE(length);\n      // unknown seems to work better here - might revisit later.\n\n\n      this.writeBuffer(UNKNOWN_PLP_LEN); // In the UNKNOWN_PLP_LEN case, the data is represented as a series of zero or more chunks.\n\n      if (length > 0) {\n        // One chunk.\n        this.writeUInt32LE(length);\n\n        if (value instanceof Buffer) {\n          this.writeBuffer(value);\n        } else {\n          this.makeRoomFor(length); // $FlowFixMe https://github.com/facebook/flow/pull/5398\n\n          this.buffer.write(value, this.position, encoding);\n          this.position += length;\n        }\n      } // PLP_TERMINATOR (no more chunks).\n\n\n      this.writeUInt32LE(0);\n    }\n  }, {\n    key: 'writeBuffer',\n    value: function writeBuffer(value) {\n      var length = value.length;\n      this.makeRoomFor(length);\n      value.copy(this.buffer, this.position);\n      this.position += length;\n    }\n  }, {\n    key: 'writeMoney',\n    value: function writeMoney(value) {\n      this.writeInt32LE(Math.floor(value * SHIFT_RIGHT_32));\n      this.writeInt32LE(value & -1);\n    }\n  }, {\n    key: 'data',\n    get: function get() {\n      this.newBuffer(0);\n      return this.compositeBuffer;\n    }\n  }]);\n  return WritableTrackingBuffer;\n}();","map":null,"metadata":{},"sourceType":"script"}