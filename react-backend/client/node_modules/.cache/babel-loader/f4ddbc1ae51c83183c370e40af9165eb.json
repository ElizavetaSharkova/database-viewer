{"ast":null,"code":"'use strict';\n\nvar _isInteger = require('babel-runtime/core-js/number/is-integer');\n\nvar _isInteger2 = _interopRequireDefault(_isInteger);\n\nvar _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar deprecate = require('depd')('tedious');\n\nvar crypto = require('crypto');\n\nvar os = require('os');\n\nvar BulkLoad = require('./bulk-load');\n\nvar Debug = require('./debug');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar InstanceLookup = require('./instance-lookup').InstanceLookup;\n\nvar TransientErrorLookup = require('./transient-error-lookup.js').TransientErrorLookup;\n\nvar TYPE = require('./packet').TYPE;\n\nvar PreloginPayload = require('./prelogin-payload');\n\nvar Login7Payload = require('./login7-payload');\n\nvar NTLMResponsePayload = require('./ntlm-payload');\n\nvar Request = require('./request');\n\nvar RpcRequestPayload = require('./rpcrequest-payload');\n\nvar SqlBatchPayload = require('./sqlbatch-payload');\n\nvar MessageIO = require('./message-io');\n\nvar TokenStreamParser = require('./token/token-stream-parser').Parser;\n\nvar Transaction = require('./transaction').Transaction;\n\nvar ISOLATION_LEVEL = require('./transaction').ISOLATION_LEVEL;\n\nvar ConnectionError = require('./errors').ConnectionError;\n\nvar RequestError = require('./errors').RequestError;\n\nvar Connector = require('./connector').Connector;\n\nvar libraryName = require('./library').name;\n\nvar versions = require('./tds-versions').versions;\n\nvar _require = require('./ntlm'),\n    createNTLMRequest = _require.createNTLMRequest; // A rather basic state machine for managing a connection.\n// Implements something approximating s3.2.1.\n\n\nvar KEEP_ALIVE_INITIAL_DELAY = 30 * 1000;\nvar DEFAULT_CONNECT_TIMEOUT = 15 * 1000;\nvar DEFAULT_CLIENT_REQUEST_TIMEOUT = 15 * 1000;\nvar DEFAULT_CANCEL_TIMEOUT = 5 * 1000;\nvar DEFAULT_CONNECT_RETRY_INTERVAL = 500;\nvar DEFAULT_PACKET_SIZE = 4 * 1024;\nvar DEFAULT_TEXTSIZE = '2147483647';\nvar DEFAULT_DATEFIRST = 7;\nvar DEFAULT_PORT = 1433;\nvar DEFAULT_TDS_VERSION = '7_4';\nvar DEFAULT_LANGUAGE = 'us_english';\nvar DEFAULT_DATEFORMAT = 'mdy';\n\nfunction deprecateNonBooleanConfigValue(optionName, value) {\n  if (typeof value !== 'boolean') {\n    deprecate(\"Passing non-boolean values for \".concat(optionName, \" is deprecated and will be removed. Please specify `true` or `false` instead.\"));\n  }\n}\n\nfunction deprecateNullConfigValue(optionName, value) {\n  if (value === null) {\n    deprecate(\"Passing `null` for \".concat(optionName, \" is deprecated and will be removed. Please pass an explicit value or `undefined` instead.\"));\n  }\n}\n\nfunction deprecateNullFallbackToDefaultConfigValue(optionName, value) {\n  if (value === null) {\n    deprecate(\"Passing `null` for \".concat(optionName, \" will not fallback to a default value in future tedious versions. Please set a value explicitly if you require a different value from the one configured for your target SQL Server.\"));\n  }\n}\n\nfunction deprecateNonStringConfigValue(optionName, value) {\n  if (typeof value !== 'string') {\n    deprecate(\"Passing non-string values for \".concat(optionName, \" will throw an error in future tedious versions. Please pass a string instead.\"));\n  }\n}\n\nfunction deprecateNonNumberConfigValue(optionName, value) {\n  if (typeof value !== 'number') {\n    deprecate(\"Passing non-number values for \".concat(optionName, \" will throw an error in future tedious versions. Please pass a number instead.\"));\n  }\n}\n\nvar Connection = function (_EventEmitter) {\n  (0, _inherits3.default)(Connection, _EventEmitter);\n\n  function Connection(config) {\n    (0, _classCallCheck3.default)(this, Connection);\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (Connection.__proto__ || (0, _getPrototypeOf2.default)(Connection)).call(this));\n\n    if (!config) {\n      throw new TypeError('No connection configuration given');\n    }\n\n    if (typeof config.server !== 'string') {\n      throw new TypeError('Invalid server: ' + config.server);\n    }\n\n    if (config.domain != undefined) {\n      deprecateNonStringConfigValue('domain', config.domain);\n    }\n\n    deprecateNullConfigValue('domain', config.domain);\n\n    if (config.userName != undefined) {\n      deprecateNonStringConfigValue('userName', config.userName);\n    }\n\n    deprecateNullConfigValue('userName', config.userName);\n\n    if (config.password != undefined) {\n      deprecateNonStringConfigValue('password', config.password);\n    }\n\n    deprecateNullConfigValue('password', config.password);\n    _this.config = {\n      server: config.server,\n      userName: config.userName,\n      password: config.password,\n      domain: config.domain && config.domain.toUpperCase(),\n      options: {\n        abortTransactionOnError: false,\n        appName: undefined,\n        camelCaseColumns: false,\n        cancelTimeout: DEFAULT_CANCEL_TIMEOUT,\n        columnNameReplacer: undefined,\n        connectionRetryInterval: DEFAULT_CONNECT_RETRY_INTERVAL,\n        connectTimeout: DEFAULT_CONNECT_TIMEOUT,\n        connectionIsolationLevel: ISOLATION_LEVEL.READ_COMMITTED,\n        cryptoCredentialsDetails: {},\n        database: undefined,\n        datefirst: DEFAULT_DATEFIRST,\n        dateFormat: DEFAULT_DATEFORMAT,\n        debug: {\n          data: false,\n          packet: false,\n          payload: false,\n          token: false\n        },\n        enableAnsiNull: true,\n        enableAnsiNullDefault: true,\n        enableAnsiPadding: true,\n        enableAnsiWarnings: true,\n        enableArithAbort: false,\n        enableConcatNullYieldsNull: true,\n        enableCursorCloseOnCommit: undefined,\n        enableImplicitTransactions: false,\n        enableNumericRoundabort: false,\n        enableQuotedIdentifier: true,\n        encrypt: false,\n        fallbackToDefaultDb: false,\n        instanceName: undefined,\n        isolationLevel: ISOLATION_LEVEL.READ_COMMITTED,\n        language: DEFAULT_LANGUAGE,\n        localAddress: undefined,\n        maxRetriesOnTransientErrors: 3,\n        multiSubnetFailover: false,\n        packetSize: DEFAULT_PACKET_SIZE,\n        port: DEFAULT_PORT,\n        readOnlyIntent: false,\n        requestTimeout: DEFAULT_CLIENT_REQUEST_TIMEOUT,\n        rowCollectionOnDone: false,\n        rowCollectionOnRequestCompletion: false,\n        tdsVersion: DEFAULT_TDS_VERSION,\n        textsize: DEFAULT_TEXTSIZE,\n        trustServerCertificate: true,\n        useColumnNames: false,\n        useUTC: true\n      }\n    };\n\n    if (config.options) {\n      if (config.options.port && config.options.instanceName) {\n        throw new Error('Port and instanceName are mutually exclusive, but ' + config.options.port + ' and ' + config.options.instanceName + ' provided');\n      }\n\n      if (config.options.abortTransactionOnError != undefined) {\n        if (typeof config.options.abortTransactionOnError !== 'boolean') {\n          throw new TypeError('options.abortTransactionOnError must be a boolean (true or false).');\n        }\n\n        _this.config.options.abortTransactionOnError = config.options.abortTransactionOnError;\n      }\n\n      deprecateNullFallbackToDefaultConfigValue('options.abortTransactionOnError', config.options.abortTransactionOnError);\n\n      if (config.options.appName != undefined) {\n        deprecateNonStringConfigValue('options.appName', config.options.appName);\n        _this.config.options.appName = config.options.appName;\n      }\n\n      deprecateNullConfigValue('options.appName', config.options.appName);\n\n      if (config.options.camelCaseColumns != undefined) {\n        deprecateNonBooleanConfigValue('options.camelCaseColumns', config.options.camelCaseColumns);\n        _this.config.options.camelCaseColumns = config.options.camelCaseColumns;\n      }\n\n      deprecateNullConfigValue('options.camelCaseColumns', config.options.camelCaseColumns);\n\n      if (config.options.cancelTimeout != undefined) {\n        _this.config.options.cancelTimeout = config.options.cancelTimeout;\n      }\n\n      deprecateNullConfigValue('options.cancelTimeout', config.options.cancelTimeout);\n\n      if (config.options.columnNameReplacer) {\n        if (typeof config.options.columnNameReplacer !== 'function') {\n          throw new TypeError('options.columnNameReplacer must be a function or null.');\n        }\n\n        _this.config.options.columnNameReplacer = config.options.columnNameReplacer;\n      }\n\n      deprecateNullConfigValue('options.columnNameReplacer', config.options.columnNameReplacer);\n\n      if (config.options.connectTimeout) {\n        _this.config.options.connectTimeout = config.options.connectTimeout;\n      }\n\n      deprecateNullConfigValue('options.connectTimeout', config.options.connectTimeout);\n\n      if (config.options.connectionIsolationLevel) {\n        _this.config.options.connectionIsolationLevel = config.options.connectionIsolationLevel;\n      }\n\n      deprecateNullFallbackToDefaultConfigValue('options.connectionIsolationLevel', config.options.connectionIsolationLevel);\n\n      if (config.options.cryptoCredentialsDetails) {\n        _this.config.options.cryptoCredentialsDetails = config.options.cryptoCredentialsDetails;\n      }\n\n      deprecateNullConfigValue('options.cryptoCredentialsDetails', config.options.cryptoCredentialsDetails);\n\n      if (config.options.database != undefined) {\n        deprecateNonStringConfigValue('options.database', config.options.database);\n        _this.config.options.database = config.options.database;\n      }\n\n      deprecateNullConfigValue('options.database', config.options.database);\n\n      if (config.options.datefirst) {\n        if (config.options.datefirst < 1 || config.options.datefirst > 7) {\n          throw new RangeError('DateFirst should be >= 1 and <= 7');\n        }\n\n        deprecateNonNumberConfigValue('options.datefirst', config.options.datefirst);\n        _this.config.options.datefirst = config.options.datefirst;\n      }\n\n      deprecateNullFallbackToDefaultConfigValue('options.datefirst', config.options.datefirst);\n\n      if (config.options.dateFormat != undefined) {\n        deprecateNonStringConfigValue('options.dateFormat', config.options.dateFormat);\n        _this.config.options.dateFormat = config.options.dateFormat;\n      }\n\n      deprecateNullFallbackToDefaultConfigValue('options.dateFormat', config.options.dateFormat);\n\n      if (config.options.debug) {\n        if (config.options.debug.data != undefined) {\n          deprecateNonBooleanConfigValue('options.debug.data', config.options.debug.data);\n          _this.config.options.debug.data = config.options.debug.data;\n        }\n\n        deprecateNullConfigValue('options.debug.data', config.options.debug.data);\n\n        if (config.options.debug.packet != undefined) {\n          deprecateNonBooleanConfigValue('options.debug.packet', config.options.debug.packet);\n          _this.config.options.debug.packet = config.options.debug.packet;\n        }\n\n        deprecateNullConfigValue('options.debug.packet', config.options.debug.packet);\n\n        if (config.options.debug.payload != undefined) {\n          deprecateNonBooleanConfigValue('options.debug.payload', config.options.debug.payload);\n          _this.config.options.debug.payload = config.options.debug.payload;\n        }\n\n        deprecateNullConfigValue('options.debug.payload', config.options.debug.payload);\n\n        if (config.options.debug.token != undefined) {\n          deprecateNonBooleanConfigValue('options.debug.token', config.options.debug.token);\n          _this.config.options.debug.token = config.options.debug.token;\n        }\n\n        deprecateNullConfigValue('options.debug.token', config.options.debug.token);\n      }\n\n      if (config.options.enableAnsiNull != undefined) {\n        if (typeof config.options.enableAnsiNull !== 'boolean') {\n          throw new TypeError('options.enableAnsiNull must be a boolean (true or false).');\n        }\n\n        _this.config.options.enableAnsiNull = config.options.enableAnsiNull;\n      }\n\n      deprecateNullFallbackToDefaultConfigValue('options.enableAnsiNull', config.options.enableAnsiNull);\n\n      if (config.options.enableAnsiNullDefault != undefined) {\n        if (typeof config.options.enableAnsiNullDefault !== 'boolean') {\n          throw new TypeError('options.enableAnsiNullDefault must be a boolean (true or false).');\n        }\n\n        _this.config.options.enableAnsiNullDefault = config.options.enableAnsiNullDefault;\n      }\n\n      deprecateNullFallbackToDefaultConfigValue('options.enableAnsiNullDefault', config.options.enableAnsiNullDefault);\n\n      if (config.options.enableAnsiPadding != undefined) {\n        if (typeof config.options.enableAnsiPadding !== 'boolean') {\n          throw new TypeError('options.enableAnsiPadding must be a boolean (true or false).');\n        }\n\n        _this.config.options.enableAnsiPadding = config.options.enableAnsiPadding;\n      }\n\n      deprecateNullFallbackToDefaultConfigValue('options.enableAnsiPadding', config.options.enableAnsiPadding);\n\n      if (config.options.enableAnsiWarnings != undefined) {\n        if (typeof config.options.enableAnsiWarnings !== 'boolean') {\n          throw new TypeError('options.enableAnsiWarnings must be a boolean (true or false).');\n        }\n\n        _this.config.options.enableAnsiWarnings = config.options.enableAnsiWarnings;\n      }\n\n      deprecateNullFallbackToDefaultConfigValue('options.enableAnsiWarnings', config.options.enableAnsiWarnings);\n\n      if (config.options.enableArithAbort !== undefined) {\n        if (typeof config.options.enableArithAbort !== 'boolean') {\n          throw new TypeError('options.enableArithAbort must be a boolean (true or false).');\n        }\n\n        _this.config.options.enableArithAbort = config.options.enableArithAbort;\n      }\n\n      deprecateNullFallbackToDefaultConfigValue('options.enableArithAbort', config.options.enableArithAbort);\n\n      if (config.options.enableConcatNullYieldsNull != undefined) {\n        if (typeof config.options.enableConcatNullYieldsNull !== 'boolean') {\n          throw new TypeError('options.enableConcatNullYieldsNull must be a boolean (true or false).');\n        }\n\n        _this.config.options.enableConcatNullYieldsNull = config.options.enableConcatNullYieldsNull;\n      }\n\n      deprecateNullFallbackToDefaultConfigValue('options.enableConcatNullYieldsNull', config.options.enableConcatNullYieldsNull);\n\n      if (config.options.enableCursorCloseOnCommit != undefined) {\n        if (typeof config.options.enableCursorCloseOnCommit !== 'boolean') {\n          throw new TypeError('options.enableCursorCloseOnCommit must be a boolean (true or false).');\n        }\n\n        _this.config.options.enableCursorCloseOnCommit = config.options.enableCursorCloseOnCommit;\n      }\n\n      deprecateNullFallbackToDefaultConfigValue('options.enableCursorCloseOnCommit', config.options.enableCursorCloseOnCommit);\n\n      if (config.options.enableImplicitTransactions != undefined) {\n        if (typeof config.options.enableImplicitTransactions !== 'boolean') {\n          throw new TypeError('options.enableImplicitTransactions must be a boolean (true or false).');\n        }\n\n        _this.config.options.enableImplicitTransactions = config.options.enableImplicitTransactions;\n      }\n\n      deprecateNullFallbackToDefaultConfigValue('options.enableImplicitTransactions', config.options.enableImplicitTransactions);\n\n      if (config.options.enableNumericRoundabort != undefined) {\n        if (typeof config.options.enableNumericRoundabort !== 'boolean') {\n          throw new TypeError('options.enableNumericRoundabort must be a boolean (true or false).');\n        }\n\n        _this.config.options.enableNumericRoundabort = config.options.enableNumericRoundabort;\n      }\n\n      deprecateNullFallbackToDefaultConfigValue('options.enableNumericRoundabort', config.options.enableNumericRoundabort);\n\n      if (config.options.enableQuotedIdentifier !== undefined) {\n        if (typeof config.options.enableQuotedIdentifier !== 'boolean') {\n          throw new TypeError('options.enableQuotedIdentifier must be a boolean (true or false).');\n        }\n\n        _this.config.options.enableQuotedIdentifier = config.options.enableQuotedIdentifier;\n      }\n\n      deprecateNullFallbackToDefaultConfigValue('options.enableQuotedIdentifier', config.options.enableQuotedIdentifier);\n\n      if (config.options.encrypt != undefined) {\n        deprecateNonBooleanConfigValue('options.encrypt', config.options.encrypt);\n        _this.config.options.encrypt = config.options.encrypt;\n      } else {\n        deprecate('The default value for `options.encrypt` will change from `false` to `true`. Please pass `false` explicitly if you want to retain current behaviour.');\n      }\n\n      deprecateNullConfigValue('options.encrypt', config.options.encrypt);\n\n      if (config.options.fallbackToDefaultDb != undefined) {\n        deprecateNonBooleanConfigValue('options.fallbackToDefaultDb', config.options.fallbackToDefaultDb);\n        _this.config.options.fallbackToDefaultDb = config.options.fallbackToDefaultDb;\n      }\n\n      deprecateNullConfigValue('options.fallbackToDefaultDb', config.options.fallbackToDefaultDb);\n\n      if (config.options.instanceName != undefined) {\n        deprecateNonStringConfigValue('options.instanceName', config.options.instanceName);\n        _this.config.options.instanceName = config.options.instanceName;\n        _this.config.options.port = undefined;\n      }\n\n      deprecateNullConfigValue('options.instanceName', config.options.instanceName);\n\n      if (config.options.isolationLevel) {\n        _this.config.options.isolationLevel = config.options.isolationLevel;\n      }\n\n      deprecateNullConfigValue('options.isolationLevel', config.options.isolationLevel);\n\n      if (config.options.language != undefined) {\n        deprecateNonStringConfigValue('options.language', config.options.language);\n        _this.config.options.language = config.options.language;\n      }\n\n      deprecateNullFallbackToDefaultConfigValue('options.language', config.options.language);\n\n      if (config.options.localAddress != undefined) {\n        _this.config.options.localAddress = config.options.localAddress;\n      }\n\n      deprecateNullConfigValue('options.localAddress', config.options.localAddress);\n\n      if (config.options.multiSubnetFailover != undefined) {\n        deprecateNonBooleanConfigValue('options.multiSubnetFailover', config.options.multiSubnetFailover);\n        _this.config.options.multiSubnetFailover = !!config.options.multiSubnetFailover;\n      }\n\n      deprecateNullConfigValue('options.multiSubnetFailover', config.options.multiSubnetFailover);\n\n      if (config.options.packetSize) {\n        deprecateNonNumberConfigValue('options.packetSize', config.options.packetSize);\n        _this.config.options.packetSize = config.options.packetSize;\n      }\n\n      deprecateNullConfigValue('options.packetSize', config.options.packetSize);\n\n      if (config.options.port) {\n        if (config.options.port <= 0 || config.options.port >= 65536) {\n          throw new RangeError('Port must be > 0 and < 65536');\n        }\n\n        deprecateNonNumberConfigValue('options.port', config.options.port);\n        _this.config.options.port = config.options.port;\n        _this.config.options.instanceName = undefined;\n      }\n\n      deprecateNullConfigValue('options.port', config.options.port);\n\n      if (config.options.readOnlyIntent != undefined) {\n        deprecateNonBooleanConfigValue('options.readOnlyIntent', config.options.readOnlyIntent);\n        _this.config.options.readOnlyIntent = config.options.readOnlyIntent;\n      }\n\n      deprecateNullConfigValue('options.readOnlyIntent', config.options.readOnlyIntent);\n\n      if (config.options.requestTimeout != undefined) {\n        deprecateNonNumberConfigValue('options.requestTimeout', config.options.requestTimeout);\n        _this.config.options.requestTimeout = config.options.requestTimeout;\n      }\n\n      deprecateNullConfigValue('options.requestTimeout', config.options.requestTimeout);\n\n      if (config.options.maxRetriesOnTransientErrors != undefined) {\n        if (!(0, _isInteger2.default)(config.options.maxRetriesOnTransientErrors) || config.options.maxRetriesOnTransientErrors < 0) {\n          throw new RangeError('options.maxRetriesOnTransientErrors must be a non-negative integer.');\n        }\n\n        _this.config.options.maxRetriesOnTransientErrors = config.options.maxRetriesOnTransientErrors;\n      }\n\n      deprecateNullConfigValue('options.maxRetriesOnTransientErrors', config.options.maxRetriesOnTransientErrors);\n\n      if (config.options.connectionRetryInterval != undefined) {\n        if (!(0, _isInteger2.default)(config.options.connectionRetryInterval) || config.options.connectionRetryInterval <= 0) {\n          throw new TypeError('options.connectionRetryInterval must be a non-zero positive integer.');\n        }\n\n        _this.config.options.connectionRetryInterval = config.options.connectionRetryInterval;\n      }\n\n      deprecateNullConfigValue('options.connectionRetryInterval', config.options.connectionRetryInterval);\n\n      if (config.options.rowCollectionOnDone != undefined) {\n        deprecateNonBooleanConfigValue('options.rowCollectionOnDone', config.options.rowCollectionOnDone);\n        _this.config.options.rowCollectionOnDone = config.options.rowCollectionOnDone;\n      }\n\n      deprecateNullConfigValue('options.rowCollectionOnDone', config.options.rowCollectionOnDone);\n\n      if (config.options.rowCollectionOnRequestCompletion != undefined) {\n        deprecateNonBooleanConfigValue('options.rowCollectionOnRequestCompletion', config.options.rowCollectionOnRequestCompletion);\n        _this.config.options.rowCollectionOnRequestCompletion = config.options.rowCollectionOnRequestCompletion;\n      }\n\n      deprecateNullConfigValue('options.rowCollectionOnRequestCompletion', config.options.rowCollectionOnRequestCompletion);\n\n      if (config.options.tdsVersion) {\n        deprecateNonStringConfigValue('options.tdsVersion', config.options.tdsVersion);\n        _this.config.options.tdsVersion = config.options.tdsVersion;\n      }\n\n      deprecateNullConfigValue('options.tdsVersion', config.options.tdsVersion);\n\n      if (config.options.textsize) {\n        deprecateNonNumberConfigValue('options.textsize', config.options.textsize);\n        _this.config.options.textsize = config.options.textsize;\n      }\n\n      deprecateNullFallbackToDefaultConfigValue('options.textsize', config.options.textsize);\n\n      if (config.options.trustServerCertificate != undefined) {\n        deprecateNonBooleanConfigValue('options.trustServerCertificate', config.options.trustServerCertificate);\n        _this.config.options.trustServerCertificate = config.options.trustServerCertificate;\n      }\n\n      deprecateNullConfigValue('options.trustServerCertificate', config.options.trustServerCertificate);\n\n      if (config.options.useColumnNames != undefined) {\n        deprecateNonBooleanConfigValue('options.useColumnNames', config.options.useColumnNames);\n        _this.config.options.useColumnNames = config.options.useColumnNames;\n      }\n\n      deprecateNullConfigValue('options.useColumnNames', config.options.useColumnNames);\n\n      if (config.options.useUTC != undefined) {\n        deprecateNonBooleanConfigValue('options.useUTC', config.options.useUTC);\n        _this.config.options.useUTC = config.options.useUTC;\n      }\n\n      deprecateNullConfigValue('options.useUTC', config.options.useUTC);\n    }\n\n    _this.createDebug();\n\n    _this.createTokenStreamParser();\n\n    _this.inTransaction = false;\n    _this.transactionDescriptors = [new Buffer([0, 0, 0, 0, 0, 0, 0, 0])];\n\n    _this.transitionTo(_this.STATE.CONNECTING);\n\n    if (_this.config.options.tdsVersion < '7_2') {\n      // 'beginTransaction', 'commitTransaction' and 'rollbackTransaction'\n      // events are utilized to maintain inTransaction property state which in\n      // turn is used in managing transactions. These events are only fired for\n      // TDS version 7.2 and beyond. The properties below are used to emulate\n      // equivalent behavior for TDS versions before 7.2.\n      _this.transactionDepth = 0;\n      _this.isSqlBatch = false;\n    }\n\n    _this.curTransientRetryCount = 0;\n    _this.transientErrorLookup = new TransientErrorLookup();\n    _this.cleanupTypeEnum = {\n      NORMAL: 0,\n      REDIRECT: 1,\n      RETRY: 2\n    };\n    return _this;\n  }\n\n  (0, _createClass3.default)(Connection, [{\n    key: 'close',\n    value: function close() {\n      this.transitionTo(this.STATE.FINAL);\n    }\n  }, {\n    key: 'initialiseConnection',\n    value: function initialiseConnection() {\n      this.connect();\n      this.createConnectTimer();\n    }\n  }, {\n    key: 'cleanupConnection',\n    value: function cleanupConnection(cleanupTypeEnum) {\n      if (!this.closed) {\n        this.clearConnectTimer();\n        this.clearRequestTimer();\n        this.clearRetryTimer();\n        this.closeConnection();\n\n        if (cleanupTypeEnum === this.cleanupTypeEnum.REDIRECT) {\n          this.emit('rerouting');\n        } else if (cleanupTypeEnum !== this.cleanupTypeEnum.RETRY) {\n          this.emit('end');\n        }\n\n        if (this.request) {\n          var err = RequestError('Connection closed before request completed.', 'ECLOSE');\n          this.request.callback(err);\n          this.request = undefined;\n        }\n\n        this.closed = true;\n        this.loggedIn = false;\n        this.loginError = null;\n      }\n    }\n  }, {\n    key: 'createDebug',\n    value: function createDebug() {\n      var _this2 = this;\n\n      this.debug = new Debug(this.config.options.debug);\n      this.debug.on('debug', function (message) {\n        _this2.emit('debug', message);\n      });\n    }\n  }, {\n    key: 'createTokenStreamParser',\n    value: function createTokenStreamParser() {\n      var _this3 = this;\n\n      this.tokenStreamParser = new TokenStreamParser(this.debug, undefined, this.config.options);\n      this.tokenStreamParser.on('infoMessage', function (token) {\n        _this3.emit('infoMessage', token);\n      });\n      this.tokenStreamParser.on('sspichallenge', function (token) {\n        if (token.ntlmpacket) {\n          _this3.ntlmpacket = token.ntlmpacket;\n          _this3.ntlmpacketBuffer = token.ntlmpacketBuffer;\n        }\n\n        _this3.emit('sspichallenge', token);\n      });\n      this.tokenStreamParser.on('errorMessage', function (token) {\n        _this3.emit('errorMessage', token);\n\n        if (_this3.loggedIn) {\n          if (_this3.request) {\n            _this3.request.error = RequestError(token.message, 'EREQUEST');\n            _this3.request.error.number = token.number;\n            _this3.request.error.state = token.state;\n            _this3.request.error['class'] = token['class'];\n            _this3.request.error.serverName = token.serverName;\n            _this3.request.error.procName = token.procName;\n            _this3.request.error.lineNumber = token.lineNumber;\n          }\n        } else {\n          var isLoginErrorTransient = _this3.transientErrorLookup.isTransientError(token.number);\n\n          if (isLoginErrorTransient && _this3.curTransientRetryCount !== _this3.config.options.maxRetriesOnTransientErrors) {\n            _this3.debug.log('Initiating retry on transient error = ', token.number);\n\n            _this3.transitionTo(_this3.STATE.TRANSIENT_FAILURE_RETRY);\n          } else {\n            _this3.loginError = ConnectionError(token.message, 'ELOGIN');\n          }\n        }\n      });\n      this.tokenStreamParser.on('databaseChange', function (token) {\n        _this3.emit('databaseChange', token.newValue);\n      });\n      this.tokenStreamParser.on('languageChange', function (token) {\n        _this3.emit('languageChange', token.newValue);\n      });\n      this.tokenStreamParser.on('charsetChange', function (token) {\n        _this3.emit('charsetChange', token.newValue);\n      });\n      this.tokenStreamParser.on('loginack', function (token) {\n        if (!token.tdsVersion) {\n          // unsupported TDS version\n          _this3.loginError = ConnectionError('Server responded with unknown TDS version.', 'ETDS');\n          _this3.loggedIn = false;\n          return;\n        }\n\n        if (!token['interface']) {\n          // unsupported interface\n          _this3.loginError = ConnectionError('Server responded with unsupported interface.', 'EINTERFACENOTSUPP');\n          _this3.loggedIn = false;\n          return;\n        } // use negotiated version\n\n\n        _this3.config.options.tdsVersion = token.tdsVersion;\n        _this3.loggedIn = true;\n      });\n      this.tokenStreamParser.on('routingChange', function (token) {\n        _this3.routingData = token.newValue;\n\n        _this3.dispatchEvent('routingChange');\n      });\n      this.tokenStreamParser.on('packetSizeChange', function (token) {\n        _this3.messageIo.packetSize(token.newValue);\n      }); // A new top-level transaction was started. This is not fired\n      // for nested transactions.\n\n      this.tokenStreamParser.on('beginTransaction', function (token) {\n        _this3.transactionDescriptors.push(token.newValue);\n\n        _this3.inTransaction = true;\n      }); // A top-level transaction was committed. This is not fired\n      // for nested transactions.\n\n      this.tokenStreamParser.on('commitTransaction', function () {\n        _this3.transactionDescriptors.length = 1;\n        _this3.inTransaction = false;\n      }); // A top-level transaction was rolled back. This is not fired\n      // for nested transactions. This is also fired if a batch\n      // aborting error happened that caused a rollback.\n\n      this.tokenStreamParser.on('rollbackTransaction', function () {\n        _this3.transactionDescriptors.length = 1; // An outermost transaction was rolled back. Reset the transaction counter\n\n        _this3.inTransaction = false;\n\n        _this3.emit('rollbackTransaction');\n      });\n      this.tokenStreamParser.on('columnMetadata', function (token) {\n        if (_this3.request) {\n          var columns = void 0;\n\n          if (_this3.config.options.useColumnNames) {\n            columns = {};\n\n            for (var j = 0, len = token.columns.length; j < len; j++) {\n              var col = token.columns[j];\n\n              if (columns[col.colName] == null) {\n                columns[col.colName] = col;\n              }\n            }\n          } else {\n            columns = token.columns;\n          }\n\n          _this3.request.emit('columnMetadata', columns);\n        } else {\n          _this3.emit('error', new Error(\"Received 'columnMetadata' when no sqlRequest is in progress\"));\n\n          _this3.close();\n        }\n      });\n      this.tokenStreamParser.on('order', function (token) {\n        if (_this3.request) {\n          _this3.request.emit('order', token.orderColumns);\n        } else {\n          _this3.emit('error', new Error(\"Received 'order' when no sqlRequest is in progress\"));\n\n          _this3.close();\n        }\n      });\n      this.tokenStreamParser.on('row', function (token) {\n        if (_this3.request) {\n          if (_this3.config.options.rowCollectionOnRequestCompletion) {\n            _this3.request.rows.push(token.columns);\n          }\n\n          if (_this3.config.options.rowCollectionOnDone) {\n            _this3.request.rst.push(token.columns);\n          }\n\n          if (!(_this3.state === _this3.STATE.SENT_ATTENTION && _this3.request.paused)) {\n            _this3.request.emit('row', token.columns);\n          }\n        } else {\n          _this3.emit('error', new Error(\"Received 'row' when no sqlRequest is in progress\"));\n\n          _this3.close();\n        }\n      });\n      this.tokenStreamParser.on('returnStatus', function (token) {\n        if (_this3.request) {\n          // Keep value for passing in 'doneProc' event.\n          _this3.procReturnStatusValue = token.value;\n        }\n      });\n      this.tokenStreamParser.on('returnValue', function (token) {\n        if (_this3.request) {\n          _this3.request.emit('returnValue', token.paramName, token.value, token.metadata);\n        }\n      });\n      this.tokenStreamParser.on('doneProc', function (token) {\n        if (_this3.request) {\n          _this3.request.emit('doneProc', token.rowCount, token.more, _this3.procReturnStatusValue, _this3.request.rst);\n\n          _this3.procReturnStatusValue = undefined;\n\n          if (token.rowCount !== undefined) {\n            _this3.request.rowCount += token.rowCount;\n          }\n\n          if (_this3.config.options.rowCollectionOnDone) {\n            _this3.request.rst = [];\n          }\n        }\n      });\n      this.tokenStreamParser.on('doneInProc', function (token) {\n        if (_this3.request) {\n          _this3.request.emit('doneInProc', token.rowCount, token.more, _this3.request.rst);\n\n          if (token.rowCount !== undefined) {\n            _this3.request.rowCount += token.rowCount;\n          }\n\n          if (_this3.config.options.rowCollectionOnDone) {\n            _this3.request.rst = [];\n          }\n        }\n      });\n      this.tokenStreamParser.on('done', function (token) {\n        if (_this3.request) {\n          if (token.attention) {\n            _this3.dispatchEvent('attention');\n          }\n\n          if (token.sqlError && !_this3.request.error) {\n            // check if the DONE_ERROR flags was set, but an ERROR token was not sent.\n            _this3.request.error = RequestError('An unknown error has occurred.', 'UNKNOWN');\n          }\n\n          _this3.request.emit('done', token.rowCount, token.more, _this3.request.rst);\n\n          if (token.rowCount !== undefined) {\n            _this3.request.rowCount += token.rowCount;\n          }\n\n          if (_this3.config.options.rowCollectionOnDone) {\n            _this3.request.rst = [];\n          }\n        }\n      });\n      this.tokenStreamParser.on('endOfMessage', function () {\n        // EOM pseudo token received\n        if (_this3.state === _this3.STATE.SENT_CLIENT_REQUEST) {\n          _this3.dispatchEvent('endOfMessageMarkerReceived');\n        }\n      });\n      this.tokenStreamParser.on('resetConnection', function () {\n        _this3.emit('resetConnection');\n      });\n      this.tokenStreamParser.on('tokenStreamError', function (error) {\n        _this3.emit('error', error);\n\n        _this3.close();\n      });\n      this.tokenStreamParser.on('drain', function () {\n        // Bridge the release of backpressure from the token stream parser\n        // transform to the packet stream transform.\n        _this3.messageIo.resume();\n      });\n    }\n  }, {\n    key: 'connect',\n    value: function connect() {\n      var _this4 = this;\n\n      if (this.config.options.port) {\n        return this.connectOnPort(this.config.options.port, this.config.options.multiSubnetFailover);\n      } else {\n        return new InstanceLookup().instanceLookup({\n          server: this.config.server,\n          instanceName: this.config.options.instanceName,\n          timeout: this.config.options.connectTimeout\n        }, function (message, port) {\n          if (_this4.state === _this4.STATE.FINAL) {\n            return;\n          }\n\n          if (message) {\n            _this4.emit('connect', ConnectionError(message, 'EINSTLOOKUP'));\n          } else {\n            _this4.connectOnPort(port, _this4.config.options.multiSubnetFailover);\n          }\n        });\n      }\n    }\n  }, {\n    key: 'connectOnPort',\n    value: function connectOnPort(port, multiSubnetFailover) {\n      var _this5 = this;\n\n      var connectOpts = {\n        host: this.routingData ? this.routingData.server : this.config.server,\n        port: this.routingData ? this.routingData.port : port,\n        localAddress: this.config.options.localAddress\n      };\n      new Connector(connectOpts, multiSubnetFailover).execute(function (err, socket) {\n        if (err) {\n          return _this5.socketError(err);\n        }\n\n        if (_this5.state === _this5.STATE.FINAL) {\n          socket.destroy();\n          return;\n        }\n\n        _this5.socket = socket;\n\n        _this5.socket.on('error', function (error) {\n          _this5.socketError(error);\n        });\n\n        _this5.socket.on('close', function () {\n          _this5.socketClose();\n        });\n\n        _this5.socket.on('end', function () {\n          _this5.socketEnd();\n        });\n\n        _this5.messageIo = new MessageIO(_this5.socket, _this5.config.options.packetSize, _this5.debug);\n\n        _this5.messageIo.on('data', function (data) {\n          _this5.dispatchEvent('data', data);\n        });\n\n        _this5.messageIo.on('message', function () {\n          _this5.dispatchEvent('message');\n        });\n\n        _this5.messageIo.on('secure', function (cleartext) {\n          _this5.emit('secure', cleartext);\n        });\n\n        _this5.socketConnect();\n      });\n    }\n  }, {\n    key: 'closeConnection',\n    value: function closeConnection() {\n      if (this.socket) {\n        this.socket.destroy();\n      }\n    }\n  }, {\n    key: 'createConnectTimer',\n    value: function createConnectTimer() {\n      var _this6 = this;\n\n      this.connectTimer = setTimeout(function () {\n        _this6.connectTimeout();\n      }, this.config.options.connectTimeout);\n    }\n  }, {\n    key: 'createRequestTimer',\n    value: function createRequestTimer() {\n      var _this7 = this;\n\n      this.clearRequestTimer(); // release old timer, just to be safe\n\n      var timeout = this.request.timeout !== undefined ? this.request.timeout : this.config.options.requestTimeout;\n\n      if (timeout) {\n        this.requestTimer = setTimeout(function () {\n          _this7.requestTimeout();\n        }, timeout);\n      }\n    }\n  }, {\n    key: 'createRetryTimer',\n    value: function createRetryTimer() {\n      var _this8 = this;\n\n      this.clearRetryTimer();\n      this.retryTimer = setTimeout(function () {\n        _this8.retryTimeout();\n      }, this.config.options.connectionRetryInterval);\n    }\n  }, {\n    key: 'connectTimeout',\n    value: function connectTimeout() {\n      var message = \"Failed to connect to \".concat(this.config.server).concat(this.config.options.port ? \":\".concat(this.config.options.port) : \"\\\\\".concat(this.config.options.instanceName), \" in \").concat(this.config.options.connectTimeout, \"ms\");\n      this.debug.log(message);\n      this.emit('connect', ConnectionError(message, 'ETIMEOUT'));\n      this.connectTimer = undefined;\n      this.dispatchEvent('connectTimeout');\n    }\n  }, {\n    key: 'requestTimeout',\n    value: function requestTimeout() {\n      this.requestTimer = undefined;\n      this.messageIo.sendMessage(TYPE.ATTENTION);\n      this.transitionTo(this.STATE.SENT_ATTENTION);\n    }\n  }, {\n    key: 'retryTimeout',\n    value: function retryTimeout() {\n      this.retryTimer = undefined;\n      this.emit('retry');\n      this.transitionTo(this.STATE.CONNECTING);\n    }\n  }, {\n    key: 'clearConnectTimer',\n    value: function clearConnectTimer() {\n      if (this.connectTimer) {\n        clearTimeout(this.connectTimer);\n      }\n    }\n  }, {\n    key: 'clearRequestTimer',\n    value: function clearRequestTimer() {\n      if (this.requestTimer) {\n        clearTimeout(this.requestTimer);\n        this.requestTimer = undefined;\n      }\n    }\n  }, {\n    key: 'clearRetryTimer',\n    value: function clearRetryTimer() {\n      if (this.retryTimer) {\n        clearTimeout(this.retryTimer);\n        this.retryTimer = undefined;\n      }\n    }\n  }, {\n    key: 'transitionTo',\n    value: function transitionTo(newState) {\n      if (this.state === newState) {\n        this.debug.log('State is already ' + newState.name);\n        return;\n      }\n\n      if (this.state && this.state.exit) {\n        this.state.exit.call(this, newState);\n      }\n\n      this.debug.log('State change: ' + (this.state ? this.state.name : undefined) + ' -> ' + newState.name);\n      this.state = newState;\n\n      if (this.state.enter) {\n        this.state.enter.apply(this);\n      }\n    }\n  }, {\n    key: 'dispatchEvent',\n    value: function dispatchEvent(eventName) {\n      if (this.state.events[eventName]) {\n        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        this.state.events[eventName].apply(this, args);\n      } else {\n        this.emit('error', new Error(\"No event '\".concat(eventName, \"' in state '\").concat(this.state.name, \"'\")));\n        this.close();\n      }\n    }\n  }, {\n    key: 'socketError',\n    value: function socketError(error) {\n      if (this.state === this.STATE.CONNECTING || this.state === this.STATE.SENT_TLSSSLNEGOTIATION) {\n        var message = \"Failed to connect to \".concat(this.config.server, \":\").concat(this.config.options.port, \" - \").concat(error.message);\n        this.debug.log(message);\n        this.emit('connect', ConnectionError(message, 'ESOCKET'));\n      } else {\n        var _message = \"Connection lost - \".concat(error.message);\n\n        this.debug.log(_message);\n        this.emit('error', ConnectionError(_message, 'ESOCKET'));\n      }\n\n      this.dispatchEvent('socketError', error);\n    }\n  }, {\n    key: 'socketConnect',\n    value: function socketConnect() {\n      this.socket.setKeepAlive(true, KEEP_ALIVE_INITIAL_DELAY);\n      this.closed = false;\n      this.debug.log('connected to ' + this.config.server + ':' + this.config.options.port);\n      this.dispatchEvent('socketConnect');\n    }\n  }, {\n    key: 'socketEnd',\n    value: function socketEnd() {\n      this.debug.log('socket ended');\n\n      if (this.state !== this.STATE.FINAL) {\n        var error = new Error('socket hang up');\n        error.code = 'ECONNRESET';\n        this.socketError(error);\n      }\n    }\n  }, {\n    key: 'socketClose',\n    value: function socketClose() {\n      this.debug.log('connection to ' + this.config.server + ':' + this.config.options.port + ' closed');\n\n      if (this.state === this.STATE.REROUTING) {\n        this.debug.log('Rerouting to ' + this.routingData.server + ':' + this.routingData.port);\n        this.dispatchEvent('reconnect');\n      } else if (this.state === this.STATE.TRANSIENT_FAILURE_RETRY) {\n        var server = this.routingData ? this.routingData.server : this.server;\n        var port = this.routingData ? this.routingData.port : this.config.options.port;\n        this.debug.log('Retry after transient failure connecting to ' + server + ':' + port);\n        this.dispatchEvent('retry');\n      } else {\n        this.transitionTo(this.STATE.FINAL);\n      }\n    }\n  }, {\n    key: 'sendPreLogin',\n    value: function sendPreLogin() {\n      var payload = new PreloginPayload({\n        encrypt: this.config.options.encrypt\n      });\n      this.messageIo.sendMessage(TYPE.PRELOGIN, payload.data);\n      this.debug.payload(function () {\n        return payload.toString('  ');\n      });\n    }\n  }, {\n    key: 'emptyMessageBuffer',\n    value: function emptyMessageBuffer() {\n      this.messageBuffer = new Buffer(0);\n    }\n  }, {\n    key: 'addToMessageBuffer',\n    value: function addToMessageBuffer(data) {\n      this.messageBuffer = Buffer.concat([this.messageBuffer, data]);\n    }\n  }, {\n    key: 'processPreLoginResponse',\n    value: function processPreLoginResponse() {\n      var preloginPayload = new PreloginPayload(this.messageBuffer);\n      this.debug.payload(function () {\n        return preloginPayload.toString('  ');\n      });\n\n      if (preloginPayload.encryptionString === 'ON' || preloginPayload.encryptionString === 'REQ') {\n        if (!this.config.options.encrypt) {\n          this.emit('connect', ConnectionError(\"Server requires encryption, set 'encrypt' config option to true.\", 'EENCRYPT'));\n          return this.close();\n        }\n\n        this.dispatchEvent('tls');\n      } else {\n        this.dispatchEvent('noTls');\n      }\n    }\n  }, {\n    key: 'sendLogin7Packet',\n    value: function sendLogin7Packet(cb) {\n      var payload = new Login7Payload({\n        tdsVersion: versions[this.config.options.tdsVersion],\n        packetSize: this.config.options.packetSize,\n        clientProgVer: 0,\n        clientPid: process.pid,\n        connectionId: 0,\n        clientTimeZone: new Date().getTimezoneOffset(),\n        clientLcid: 0x00000409\n      });\n\n      if (this.config.domain) {\n        payload.sspi = createNTLMRequest({\n          domain: this.config.domain\n        });\n      } else {\n        payload.userName = this.config.userName;\n        payload.password = this.config.password;\n      }\n\n      payload.hostname = os.hostname();\n      payload.serverName = this.routingData ? this.routingData.server : this.config.server;\n      payload.appName = this.config.options.appName || 'Tedious';\n      payload.libraryName = libraryName;\n      payload.language = this.config.options.language;\n      payload.database = this.config.options.database;\n      payload.clientId = new Buffer([1, 2, 3, 4, 5, 6]);\n      payload.readOnlyIntent = this.config.options.readOnlyIntent;\n      payload.initDbFatal = !this.config.options.fallbackToDefaultDb;\n      this.routingData = undefined;\n      this.messageIo.sendMessage(TYPE.LOGIN7, payload.toBuffer());\n      this.debug.payload(function () {\n        return payload.toString('  ');\n      });\n      process.nextTick(cb);\n    }\n  }, {\n    key: 'sendNTLMResponsePacket',\n    value: function sendNTLMResponsePacket() {\n      var _this9 = this;\n\n      var payload = new NTLMResponsePayload({\n        domain: this.config.domain,\n        userName: this.config.userName,\n        password: this.config.password,\n        database: this.config.options.database,\n        appName: this.config.options.appName,\n        packetSize: this.config.options.packetSize,\n        tdsVersion: this.config.options.tdsVersion,\n        ntlmpacket: this.ntlmpacket,\n        additional: this.additional\n      });\n      this.messageIo.sendMessage(TYPE.NTLMAUTH_PKT, payload.data);\n      this.debug.payload(function () {\n        return payload.toString('  ');\n      });\n      process.nextTick(function () {\n        _this9.transitionTo(_this9.STATE.SENT_NTLM_RESPONSE);\n      });\n    } // Returns false to apply backpressure.\n\n  }, {\n    key: 'sendDataToTokenStreamParser',\n    value: function sendDataToTokenStreamParser(data) {\n      return this.tokenStreamParser.addBuffer(data);\n    } // This is an internal method that is called from Request.pause().\n    // It has to check whether the passed Request object represents the currently\n    // active request, because the application might have called Request.pause()\n    // on an old inactive Request object.\n\n  }, {\n    key: 'pauseRequest',\n    value: function pauseRequest(request) {\n      if (this.isRequestActive(request)) {\n        this.tokenStreamParser.pause();\n      }\n    } // This is an internal method that is called from Request.resume().\n\n  }, {\n    key: 'resumeRequest',\n    value: function resumeRequest(request) {\n      if (this.isRequestActive(request)) {\n        this.tokenStreamParser.resume();\n      }\n    } // Returns true if the passed request is the currently active request of the connection.\n\n  }, {\n    key: 'isRequestActive',\n    value: function isRequestActive(request) {\n      return request === this.request && this.state === this.STATE.SENT_CLIENT_REQUEST;\n    }\n  }, {\n    key: 'sendInitialSql',\n    value: function sendInitialSql() {\n      var payload = new SqlBatchPayload(this.getInitialSql(), this.currentTransactionDescriptor(), this.config.options);\n      return this.messageIo.sendMessage(TYPE.SQL_BATCH, payload.data);\n    }\n  }, {\n    key: 'getInitialSql',\n    value: function getInitialSql() {\n      var options = [];\n\n      if (this.config.options.enableAnsiNull) {\n        options.push('set ansi_nulls on');\n      } else {\n        options.push('set ansi_nulls off');\n      }\n\n      if (this.config.options.enableAnsiNullDefault) {\n        options.push('set ansi_null_dflt_on on');\n      } else {\n        options.push('set ansi_null_dflt_on off');\n      }\n\n      if (this.config.options.enableAnsiPadding) {\n        options.push('set ansi_padding on');\n      } else {\n        options.push('set ansi_padding off');\n      }\n\n      if (this.config.options.enableAnsiWarnings) {\n        options.push('set ansi_warnings on');\n      } else {\n        options.push('set ansi_warnings off');\n      }\n\n      if (this.config.options.enableArithAbort) {\n        options.push('set arithabort on');\n      } else {\n        options.push('set arithabort off');\n      }\n\n      if (this.config.options.enableConcatNullYieldsNull) {\n        options.push('set concat_null_yields_null on');\n      } else {\n        options.push('set concat_null_yields_null off');\n      }\n\n      if (this.config.options.enableCursorCloseOnCommit !== undefined) {\n        if (this.config.options.enableCursorCloseOnCommit) {\n          options.push('set cursor_close_on_commit on');\n        } else {\n          options.push('set cursor_close_on_commit off');\n        }\n      }\n\n      options.push(\"set datefirst \".concat(this.config.options.datefirst));\n      options.push(\"set dateformat \".concat(this.config.options.dateFormat));\n\n      if (this.config.options.enableImplicitTransactions) {\n        options.push('set implicit_transactions on');\n      } else {\n        options.push('set implicit_transactions off');\n      }\n\n      options.push(\"set language \".concat(this.config.options.language));\n\n      if (this.config.options.enableNumericRoundabort) {\n        options.push('set numeric_roundabort on');\n      } else {\n        options.push('set numeric_roundabort off');\n      }\n\n      if (this.config.options.enableQuotedIdentifier) {\n        options.push('set quoted_identifier on');\n      } else {\n        options.push('set quoted_identifier off');\n      }\n\n      options.push(\"set textsize \".concat(this.config.options.textsize));\n      options.push(\"set transaction isolation level \".concat(this.getIsolationLevelText(this.config.options.connectionIsolationLevel)));\n\n      if (this.config.options.abortTransactionOnError) {\n        options.push('set xact_abort on');\n      } else {\n        options.push('set xact_abort off');\n      }\n\n      return options.join('\\n');\n    }\n  }, {\n    key: 'processedInitialSql',\n    value: function processedInitialSql() {\n      this.clearConnectTimer();\n      this.emit('connect');\n    }\n  }, {\n    key: 'processLogin7Response',\n    value: function processLogin7Response() {\n      if (this.loggedIn) {\n        this.dispatchEvent('loggedIn');\n      } else {\n        if (this.loginError) {\n          this.emit('connect', this.loginError);\n        } else {\n          this.emit('connect', ConnectionError('Login failed.', 'ELOGIN'));\n        }\n\n        this.dispatchEvent('loginFailed');\n      }\n    }\n  }, {\n    key: 'processLogin7NTLMResponse',\n    value: function processLogin7NTLMResponse() {\n      if (this.ntlmpacket) {\n        this.dispatchEvent('receivedChallenge');\n      } else {\n        if (this.loginError) {\n          this.emit('connect', this.loginError);\n        } else {\n          this.emit('connect', ConnectionError('Login failed.', 'ELOGIN'));\n        }\n\n        this.dispatchEvent('loginFailed');\n      }\n    }\n  }, {\n    key: 'processLogin7NTLMAck',\n    value: function processLogin7NTLMAck() {\n      if (this.loggedIn) {\n        this.dispatchEvent('loggedIn');\n      } else {\n        if (this.loginError) {\n          this.emit('connect', this.loginError);\n        } else {\n          this.emit('connect', ConnectionError('Login failed.', 'ELOGIN'));\n        }\n\n        this.dispatchEvent('loginFailed');\n      }\n    }\n  }, {\n    key: 'execSqlBatch',\n    value: function execSqlBatch(request) {\n      this.makeRequest(request, TYPE.SQL_BATCH, new SqlBatchPayload(request.sqlTextOrProcedure, this.currentTransactionDescriptor(), this.config.options));\n    }\n  }, {\n    key: 'execSql',\n    value: function execSql(request) {\n      var _this10 = this;\n\n      request.transformIntoExecuteSqlRpc();\n\n      if (request.error != null) {\n        process.nextTick(function () {\n          _this10.debug.log(request.error.message);\n\n          request.callback(request.error);\n        });\n        return;\n      }\n\n      this.makeRequest(request, TYPE.RPC_REQUEST, new RpcRequestPayload(request, this.currentTransactionDescriptor(), this.config.options));\n    }\n    /**\n     @function newBulkLoad\n     @param {string} table - Table's name.\n     @param {Object} [options] - BulkLoad options.\n     @param {boolean} [options.checkConstraints=false] - Honors constraints during bulk load, it is disabled by default.\n     @param {boolean} [options.fireTriggers=false] - Honors insert triggers during bulk load, it is disabled by default.\n     @param {boolean} [options.keepNulls=false] - Honors null value passed, ignores the default values set on table.\n     @param {boolean} [options.tableLock=false] - Places a bulk update(BU) lock on table while performing bulk load. Uses row locks by default.\n     @param {callback} callback - Function to call after BulkLoad executes.\n    */\n\n  }, {\n    key: 'newBulkLoad',\n    value: function newBulkLoad(table, options, callback) {\n      if (callback === undefined) {\n        callback = options;\n        options = {};\n      }\n\n      if (typeof options !== 'object') {\n        throw new TypeError('\"options\" argument must be an object');\n      }\n\n      return new BulkLoad(table, this.config.options, options, callback);\n    }\n  }, {\n    key: 'execBulkLoad',\n    value: function execBulkLoad(bulkLoad) {\n      var _this11 = this;\n\n      var request = new Request(bulkLoad.getBulkInsertSql(), function (error) {\n        if (error) {\n          if (error.code === 'UNKNOWN') {\n            error.message += ' This is likely because the schema of the BulkLoad does not match the schema of the table you are attempting to insert into.';\n          }\n\n          bulkLoad.error = error;\n          bulkLoad.callback(error);\n        } else {\n          _this11.makeRequest(bulkLoad, TYPE.BULK_LOAD, bulkLoad.getPayload());\n        }\n      });\n      this.execSqlBatch(request);\n    }\n  }, {\n    key: 'prepare',\n    value: function prepare(request) {\n      request.transformIntoPrepareRpc();\n      this.makeRequest(request, TYPE.RPC_REQUEST, new RpcRequestPayload(request, this.currentTransactionDescriptor(), this.config.options));\n    }\n  }, {\n    key: 'unprepare',\n    value: function unprepare(request) {\n      request.transformIntoUnprepareRpc();\n      this.makeRequest(request, TYPE.RPC_REQUEST, new RpcRequestPayload(request, this.currentTransactionDescriptor(), this.config.options));\n    }\n  }, {\n    key: 'execute',\n    value: function execute(request, parameters) {\n      var _this12 = this;\n\n      request.transformIntoExecuteRpc(parameters);\n\n      if (request.error != null) {\n        process.nextTick(function () {\n          _this12.debug.log(request.error.message);\n\n          request.callback(request.error);\n        });\n        return;\n      }\n\n      this.makeRequest(request, TYPE.RPC_REQUEST, new RpcRequestPayload(request, this.currentTransactionDescriptor(), this.config.options));\n    }\n  }, {\n    key: 'callProcedure',\n    value: function callProcedure(request) {\n      var _this13 = this;\n\n      request.validateParameters();\n\n      if (request.error != null) {\n        process.nextTick(function () {\n          _this13.debug.log(request.error.message);\n\n          request.callback(request.error);\n        });\n        return;\n      }\n\n      this.makeRequest(request, TYPE.RPC_REQUEST, new RpcRequestPayload(request, this.currentTransactionDescriptor(), this.config.options));\n    }\n  }, {\n    key: 'beginTransaction',\n    value: function beginTransaction(callback, name, isolationLevel) {\n      var _this14 = this;\n\n      isolationLevel || (isolationLevel = this.config.options.isolationLevel);\n      var transaction = new Transaction(name || '', isolationLevel);\n\n      if (this.config.options.tdsVersion < '7_2') {\n        return this.execSqlBatch(new Request('SET TRANSACTION ISOLATION LEVEL ' + transaction.isolationLevelToTSQL() + ';BEGIN TRAN ' + transaction.name, function () {\n          _this14.transactionDepth++;\n\n          if (_this14.transactionDepth === 1) {\n            _this14.inTransaction = true;\n          }\n\n          callback.apply(undefined, arguments);\n        }));\n      }\n\n      var request = new Request(undefined, function (err) {\n        return callback(err, _this14.currentTransactionDescriptor());\n      });\n      return this.makeRequest(request, TYPE.TRANSACTION_MANAGER, transaction.beginPayload(this.currentTransactionDescriptor()));\n    }\n  }, {\n    key: 'commitTransaction',\n    value: function commitTransaction(callback, name) {\n      var _this15 = this;\n\n      var transaction = new Transaction(name || '');\n\n      if (this.config.options.tdsVersion < '7_2') {\n        return this.execSqlBatch(new Request('COMMIT TRAN ' + transaction.name, function () {\n          _this15.transactionDepth--;\n\n          if (_this15.transactionDepth === 0) {\n            _this15.inTransaction = false;\n          }\n\n          callback.apply(undefined, arguments);\n        }));\n      }\n\n      var request = new Request(undefined, callback);\n      return this.makeRequest(request, TYPE.TRANSACTION_MANAGER, transaction.commitPayload(this.currentTransactionDescriptor()));\n    }\n  }, {\n    key: 'rollbackTransaction',\n    value: function rollbackTransaction(callback, name) {\n      var _this16 = this;\n\n      var transaction = new Transaction(name || '');\n\n      if (this.config.options.tdsVersion < '7_2') {\n        return this.execSqlBatch(new Request('ROLLBACK TRAN ' + transaction.name, function () {\n          _this16.transactionDepth--;\n\n          if (_this16.transactionDepth === 0) {\n            _this16.inTransaction = false;\n          }\n\n          callback.apply(undefined, arguments);\n        }));\n      }\n\n      var request = new Request(undefined, callback);\n      return this.makeRequest(request, TYPE.TRANSACTION_MANAGER, transaction.rollbackPayload(this.currentTransactionDescriptor()));\n    }\n  }, {\n    key: 'saveTransaction',\n    value: function saveTransaction(callback, name) {\n      var _this17 = this;\n\n      var transaction = new Transaction(name);\n\n      if (this.config.options.tdsVersion < '7_2') {\n        return this.execSqlBatch(new Request('SAVE TRAN ' + transaction.name, function () {\n          _this17.transactionDepth++;\n          callback.apply(undefined, arguments);\n        }));\n      }\n\n      var request = new Request(undefined, callback);\n      return this.makeRequest(request, TYPE.TRANSACTION_MANAGER, transaction.savePayload(this.currentTransactionDescriptor()));\n    }\n  }, {\n    key: 'transaction',\n    value: function transaction(cb, isolationLevel) {\n      var _this18 = this;\n\n      if (typeof cb !== 'function') {\n        throw new TypeError('`cb` must be a function');\n      }\n\n      var useSavepoint = this.inTransaction;\n      var name = '_tedious_' + crypto.randomBytes(10).toString('hex');\n\n      var txDone = function txDone(err, done) {\n        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n          args[_key2 - 2] = arguments[_key2];\n        }\n\n        if (err) {\n          if (_this18.inTransaction && _this18.state === _this18.STATE.LOGGED_IN) {\n            return _this18.rollbackTransaction(function (txErr) {\n              done.apply(undefined, [txErr || err].concat(args));\n            }, name);\n          } else {\n            return process.nextTick(function () {\n              done.apply(undefined, [err].concat(args));\n            });\n          }\n        } else {\n          if (useSavepoint) {\n            return process.nextTick(function () {\n              if (_this18.config.options.tdsVersion < '7_2') {\n                _this18.transactionDepth--;\n              }\n\n              done.apply(undefined, [null].concat(args));\n            });\n          } else {\n            return _this18.commitTransaction(function (txErr) {\n              done.apply(undefined, [txErr].concat(args));\n            }, name);\n          }\n        }\n      };\n\n      if (useSavepoint) {\n        return this.saveTransaction(function (err) {\n          if (err) {\n            return cb(err);\n          }\n\n          if (isolationLevel) {\n            return _this18.execSqlBatch(new Request('SET transaction isolation level ' + _this18.getIsolationLevelText(isolationLevel), function (err) {\n              return cb(err, txDone);\n            }));\n          } else {\n            return cb(null, txDone);\n          }\n        }, name);\n      } else {\n        return this.beginTransaction(function (err) {\n          if (err) {\n            return cb(err);\n          }\n\n          return cb(null, txDone);\n        }, name, isolationLevel);\n      }\n    }\n  }, {\n    key: 'makeRequest',\n    value: function makeRequest(request, packetType, payload) {\n      if (this.state !== this.STATE.LOGGED_IN) {\n        var message = 'Requests can only be made in the ' + this.STATE.LOGGED_IN.name + ' state, not the ' + this.state.name + ' state';\n        this.debug.log(message);\n        request.callback(RequestError(message, 'EINVALIDSTATE'));\n      } else {\n        if (packetType === TYPE.SQL_BATCH) {\n          this.isSqlBatch = true;\n        } else {\n          this.isSqlBatch = false;\n        }\n\n        this.request = request;\n        this.request.connection = this;\n        this.request.rowCount = 0;\n        this.request.rows = [];\n        this.request.rst = [];\n        this.createRequestTimer();\n        this.messageIo.sendMessage(packetType, payload.data, this.resetConnectionOnNextRequest);\n        this.resetConnectionOnNextRequest = false;\n        this.debug.payload(function () {\n          return payload.toString('  ');\n        });\n        this.transitionTo(this.STATE.SENT_CLIENT_REQUEST);\n\n        if (request.paused) {\n          // Request.pause() has been called before the request was started\n          this.pauseRequest(request);\n        }\n      }\n    }\n  }, {\n    key: 'cancel',\n    value: function cancel() {\n      if (this.state !== this.STATE.SENT_CLIENT_REQUEST) {\n        var message = 'Requests can only be canceled in the ' + this.STATE.SENT_CLIENT_REQUEST.name + ' state, not the ' + this.state.name + ' state';\n        this.debug.log(message);\n        return false;\n      } else {\n        this.request.canceled = true;\n        this.messageIo.sendMessage(TYPE.ATTENTION);\n        this.transitionTo(this.STATE.SENT_ATTENTION);\n        return true;\n      }\n    }\n  }, {\n    key: 'reset',\n    value: function reset(callback) {\n      var _this19 = this;\n\n      var request = new Request(this.getInitialSql(), function (err) {\n        if (_this19.config.options.tdsVersion < '7_2') {\n          _this19.inTransaction = false;\n        }\n\n        callback(err);\n      });\n      this.resetConnectionOnNextRequest = true;\n      return this.execSqlBatch(request);\n    }\n  }, {\n    key: 'currentTransactionDescriptor',\n    value: function currentTransactionDescriptor() {\n      return this.transactionDescriptors[this.transactionDescriptors.length - 1];\n    }\n  }, {\n    key: 'getIsolationLevelText',\n    value: function getIsolationLevelText(isolationLevel) {\n      switch (isolationLevel) {\n        case ISOLATION_LEVEL.READ_UNCOMMITTED:\n          return 'read uncommitted';\n\n        case ISOLATION_LEVEL.REPEATABLE_READ:\n          return 'repeatable read';\n\n        case ISOLATION_LEVEL.SERIALIZABLE:\n          return 'serializable';\n\n        case ISOLATION_LEVEL.SNAPSHOT:\n          return 'snapshot';\n\n        default:\n          return 'read committed';\n      }\n    }\n  }]);\n  return Connection;\n}(EventEmitter);\n\nmodule.exports = Connection;\nConnection.prototype.STATE = {\n  CONNECTING: {\n    name: 'Connecting',\n    enter: function enter() {\n      this.initialiseConnection();\n    },\n    events: {\n      socketError: function socketError() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      connectTimeout: function connectTimeout() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      socketConnect: function socketConnect() {\n        this.sendPreLogin();\n        this.transitionTo(this.STATE.SENT_PRELOGIN);\n      }\n    }\n  },\n  SENT_PRELOGIN: {\n    name: 'SentPrelogin',\n    enter: function enter() {\n      this.emptyMessageBuffer();\n    },\n    events: {\n      socketError: function socketError() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      connectTimeout: function connectTimeout() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      data: function data(_data) {\n        this.addToMessageBuffer(_data);\n      },\n      message: function message() {\n        this.processPreLoginResponse();\n      },\n      noTls: function noTls() {\n        var _this20 = this;\n\n        this.sendLogin7Packet(function () {\n          if (_this20.config.domain) {\n            _this20.transitionTo(_this20.STATE.SENT_LOGIN7_WITH_NTLM);\n          } else {\n            _this20.transitionTo(_this20.STATE.SENT_LOGIN7_WITH_STANDARD_LOGIN);\n          }\n        });\n      },\n      tls: function tls() {\n        this.messageIo.startTls(this.config.options.cryptoCredentialsDetails, this.config.server, this.config.options.trustServerCertificate);\n        this.transitionTo(this.STATE.SENT_TLSSSLNEGOTIATION);\n      }\n    }\n  },\n  REROUTING: {\n    name: 'ReRouting',\n    enter: function enter() {\n      this.cleanupConnection(this.cleanupTypeEnum.REDIRECT);\n    },\n    events: {\n      message: function message() {},\n      socketError: function socketError() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      connectTimeout: function connectTimeout() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      reconnect: function reconnect() {\n        this.transitionTo(this.STATE.CONNECTING);\n      }\n    }\n  },\n  TRANSIENT_FAILURE_RETRY: {\n    name: 'TRANSIENT_FAILURE_RETRY',\n    enter: function enter() {\n      this.curTransientRetryCount++;\n      this.cleanupConnection(this.cleanupTypeEnum.RETRY);\n    },\n    events: {\n      message: function message() {},\n      socketError: function socketError() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      connectTimeout: function connectTimeout() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      retry: function retry() {\n        this.createRetryTimer();\n      }\n    }\n  },\n  SENT_TLSSSLNEGOTIATION: {\n    name: 'SentTLSSSLNegotiation',\n    events: {\n      socketError: function socketError() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      connectTimeout: function connectTimeout() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      data: function data(_data2) {\n        this.messageIo.tlsHandshakeData(_data2);\n      },\n      message: function message() {\n        var _this21 = this;\n\n        if (this.messageIo.tlsNegotiationComplete) {\n          this.sendLogin7Packet(function () {\n            if (_this21.config.domain) {\n              _this21.transitionTo(_this21.STATE.SENT_LOGIN7_WITH_NTLM);\n            } else {\n              _this21.transitionTo(_this21.STATE.SENT_LOGIN7_WITH_STANDARD_LOGIN);\n            }\n          });\n        }\n      }\n    }\n  },\n  SENT_LOGIN7_WITH_STANDARD_LOGIN: {\n    name: 'SentLogin7WithStandardLogin',\n    events: {\n      socketError: function socketError() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      connectTimeout: function connectTimeout() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      data: function data(_data3) {\n        this.sendDataToTokenStreamParser(_data3);\n      },\n      loggedIn: function loggedIn() {\n        this.transitionTo(this.STATE.LOGGED_IN_SENDING_INITIAL_SQL);\n      },\n      routingChange: function routingChange() {\n        this.transitionTo(this.STATE.REROUTING);\n      },\n      loginFailed: function loginFailed() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      message: function message() {\n        this.processLogin7Response();\n      }\n    }\n  },\n  SENT_LOGIN7_WITH_NTLM: {\n    name: 'SentLogin7WithNTLMLogin',\n    events: {\n      socketError: function socketError() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      connectTimeout: function connectTimeout() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      data: function data(_data4) {\n        this.sendDataToTokenStreamParser(_data4);\n      },\n      receivedChallenge: function receivedChallenge() {\n        this.sendNTLMResponsePacket();\n      },\n      loginFailed: function loginFailed() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      message: function message() {\n        this.processLogin7NTLMResponse();\n      }\n    }\n  },\n  SENT_NTLM_RESPONSE: {\n    name: 'SentNTLMResponse',\n    events: {\n      socketError: function socketError() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      connectTimeout: function connectTimeout() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      data: function data(_data5) {\n        this.sendDataToTokenStreamParser(_data5);\n      },\n      loggedIn: function loggedIn() {\n        this.transitionTo(this.STATE.LOGGED_IN_SENDING_INITIAL_SQL);\n      },\n      loginFailed: function loginFailed() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      routingChange: function routingChange() {\n        this.transitionTo(this.STATE.REROUTING);\n      },\n      message: function message() {\n        this.processLogin7NTLMAck();\n      }\n    }\n  },\n  LOGGED_IN_SENDING_INITIAL_SQL: {\n    name: 'LoggedInSendingInitialSql',\n    enter: function enter() {\n      this.sendInitialSql();\n    },\n    events: {\n      connectTimeout: function connectTimeout() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      data: function data(_data6) {\n        this.sendDataToTokenStreamParser(_data6);\n      },\n      message: function message() {\n        this.transitionTo(this.STATE.LOGGED_IN);\n        this.processedInitialSql();\n      }\n    }\n  },\n  LOGGED_IN: {\n    name: 'LoggedIn',\n    events: {\n      socketError: function socketError() {\n        this.transitionTo(this.STATE.FINAL);\n      }\n    }\n  },\n  SENT_CLIENT_REQUEST: {\n    name: 'SentClientRequest',\n    exit: function exit(nextState) {\n      this.clearRequestTimer();\n\n      if (nextState !== this.STATE.FINAL) {\n        this.tokenStreamParser.resume();\n      }\n    },\n    events: {\n      socketError: function socketError(err) {\n        var sqlRequest = this.request;\n        this.request = undefined;\n        sqlRequest.callback(err);\n        this.transitionTo(this.STATE.FINAL);\n      },\n      data: function data(_data7) {\n        this.clearRequestTimer(); // request timer is stopped on first data package\n\n        var ret = this.sendDataToTokenStreamParser(_data7);\n\n        if (ret === false) {\n          // Bridge backpressure from the token stream parser transform to the\n          // packet stream transform.\n          this.messageIo.pause();\n        }\n      },\n      message: function message() {\n        // We have to channel the 'message' (EOM) event through the token stream\n        // parser transform, to keep it in line with the flow of the tokens, when\n        // the incoming data flow is paused and resumed.\n        this.tokenStreamParser.addEndOfMessageMarker();\n      },\n      endOfMessageMarkerReceived: function endOfMessageMarkerReceived() {\n        this.transitionTo(this.STATE.LOGGED_IN);\n        var sqlRequest = this.request;\n        this.request = undefined;\n\n        if (this.config.options.tdsVersion < '7_2' && sqlRequest.error && this.isSqlBatch) {\n          this.inTransaction = false;\n        }\n\n        sqlRequest.callback(sqlRequest.error, sqlRequest.rowCount, sqlRequest.rows);\n      }\n    }\n  },\n  SENT_ATTENTION: {\n    name: 'SentAttention',\n    enter: function enter() {\n      this.attentionReceived = false;\n    },\n    events: {\n      socketError: function socketError() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      data: function data(_data8) {\n        this.sendDataToTokenStreamParser(_data8);\n      },\n      attention: function attention() {\n        this.attentionReceived = true;\n      },\n      message: function message() {\n        // 3.2.5.7 Sent Attention State\n        // Discard any data contained in the response, until we receive the attention response\n        if (this.attentionReceived) {\n          var sqlRequest = this.request;\n          this.request = undefined;\n          this.transitionTo(this.STATE.LOGGED_IN);\n\n          if (sqlRequest.canceled) {\n            sqlRequest.callback(RequestError('Canceled.', 'ECANCEL'));\n          } else {\n            var timeout = sqlRequest.timeout !== undefined ? sqlRequest.timeout : this.config.options.requestTimeout;\n            var message = 'Timeout: Request failed to complete in ' + timeout + 'ms';\n            sqlRequest.callback(RequestError(message, 'ETIMEOUT'));\n          }\n        }\n      }\n    }\n  },\n  FINAL: {\n    name: 'Final',\n    enter: function enter() {\n      this.cleanupConnection(this.cleanupTypeEnum.NORMAL);\n    },\n    events: {\n      loginFailed: function loginFailed() {// Do nothing. The connection was probably closed by the client code.\n      },\n      connectTimeout: function connectTimeout() {// Do nothing, as the timer should be cleaned up.\n      },\n      message: function message() {// Do nothing\n      },\n      socketError: function socketError() {// Do nothing\n      }\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"script"}