{"ast":null,"code":"'use strict';\n\nvar _wrapNativeSuper = require(\"C:\\\\Users\\\\elizaveta.sharkova\\\\Learning\\\\React\\\\First\\\\database-viewer\\\\node_modules\\\\@babel\\\\runtime/helpers/wrapNativeSuper\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\elizaveta.sharkova\\\\Learning\\\\React\\\\First\\\\database-viewer\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\elizaveta.sharkova\\\\Learning\\\\React\\\\First\\\\database-viewer\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\elizaveta.sharkova\\\\Learning\\\\React\\\\First\\\\database-viewer\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\elizaveta.sharkova\\\\Learning\\\\React\\\\First\\\\database-viewer\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\elizaveta.sharkova\\\\Learning\\\\React\\\\First\\\\database-viewer\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"C:\\\\Users\\\\elizaveta.sharkova\\\\Learning\\\\React\\\\First\\\\database-viewer\\\\node_modules\\\\@babel\\\\runtime/helpers/assertThisInitialized\");\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar debug = require('debug')('mssql:base');\n\nvar gp = require('generic-pool');\n\nvar TYPES = require('./datatypes').TYPES;\n\nvar declare = require('./datatypes').declare;\n\nvar ISOLATION_LEVEL = require('./isolationlevel');\n\nvar Table = require('./table');\n\nvar ConnectionString = require('./connectionstring');\n\nvar IDS = require('./utils').IDS;\n\nvar globalConnection = null;\nvar PromiseLibrary = Promise;\nvar globalConnectionHandlers = {};\nvar map = [];\nvar driver = {};\n/**\n * Register you own type map.\n *\n * @path module.exports.map\n * @param {*} jstype JS data type.\n * @param {*} sqltype SQL data type.\n */\n\nmap.register = function (jstype, sqltype) {\n  for (var index = 0; index < this.length; index++) {\n    var item = this[index];\n\n    if (item.js === jstype) {\n      this.splice(index, 1);\n      break;\n    }\n  }\n\n  this.push({\n    js: jstype,\n    sql: sqltype\n  });\n  return null;\n};\n\nmap.register(String, TYPES.NVarChar);\nmap.register(Number, TYPES.Int);\nmap.register(Boolean, TYPES.Bit);\nmap.register(Date, TYPES.DateTime);\nmap.register(Buffer, TYPES.VarBinary);\nmap.register(Table, TYPES.TVP);\n/**\n * @ignore\n */\n\nvar getTypeByValue = function getTypeByValue(value) {\n  if (value === null || value === undefined) {\n    return TYPES.NVarChar;\n  }\n\n  switch (typeof value) {\n    case 'string':\n      var _arr = Array.from(map);\n\n      for (var _i = 0; _i < _arr.length; _i++) {\n        var item = _arr[_i];\n\n        if (item.js === String) {\n          return item.sql;\n        }\n      }\n\n      return TYPES.NVarChar;\n\n    case 'number':\n      if (value % 1 === 0) {\n        return TYPES.Int;\n      } else {\n        return TYPES.Float;\n      }\n\n    case 'boolean':\n      var _arr2 = Array.from(map);\n\n      for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n        item = _arr2[_i2];\n\n        if (item.js === Boolean) {\n          return item.sql;\n        }\n      }\n\n      return TYPES.Bit;\n\n    case 'object':\n      var _arr3 = Array.from(map);\n\n      for (var _i3 = 0; _i3 < _arr3.length; _i3++) {\n        item = _arr3[_i3];\n\n        if (value instanceof item.js) {\n          return item.sql;\n        }\n      }\n\n      return TYPES.NVarChar;\n\n    default:\n      return TYPES.NVarChar;\n  }\n};\n/**\n * Class ConnectionPool.\n *\n * Internally, each `Connection` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool.\n *\n * @property {Boolean} connected If true, connection is established.\n * @property {Boolean} connecting If true, connection is being established.\n *\n * @fires ConnectionPool#connect\n * @fires ConnectionPool#close\n */\n\n\nvar ConnectionPool =\n/*#__PURE__*/\nfunction (_EventEmitter) {\n  _inherits(ConnectionPool, _EventEmitter);\n\n  /**\n   * Create new Connection.\n   *\n   * @param {Object|String} config Connection configuration object or connection string.\n   * @param {basicCallback} [callback] A callback which is called after connection has established, or an error has occurred.\n   */\n  function ConnectionPool(config, callback) {\n    var _this;\n\n    _classCallCheck(this, ConnectionPool);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ConnectionPool).call(this));\n    IDS.add(_assertThisInitialized(_assertThisInitialized(_this)), 'ConnectionPool');\n    debug('pool(%d): created', IDS.get(_assertThisInitialized(_assertThisInitialized(_this))));\n    _this.config = config;\n    _this._connected = false;\n    _this._connecting = false;\n\n    if (typeof _this.config === 'string') {\n      try {\n        _this.config = ConnectionString.resolve(_this.config, driver.name);\n      } catch (ex) {\n        if (typeof callback === 'function') {\n          return _possibleConstructorReturn(_this, callback(ex));\n        }\n\n        throw ex;\n      }\n    } // set defaults\n\n\n    _this.config.port = _this.config.port || 1433;\n    _this.config.options = _this.config.options || {};\n    _this.config.stream = _this.config.stream || false;\n    _this.config.parseJSON = _this.config.parseJSON || false;\n\n    if (/^(.*)\\\\(.*)$/.exec(_this.config.server)) {\n      _this.config.server = RegExp.$1;\n      _this.config.options.instanceName = RegExp.$2;\n    }\n\n    if (typeof callback === 'function') {\n      _this.connect(callback);\n    }\n\n    return _this;\n  }\n\n  _createClass(ConnectionPool, [{\n    key: \"acquire\",\n\n    /**\n     * Acquire connection from this connection pool.\n     *\n     * @param {ConnectionPool|Transaction|PreparedStatement} requester Requester.\n     * @param {acquireCallback} [callback] A callback which is called after connection has been acquired, or an error has occurred. If omited, method returns Promise.\n     * @return {ConnectionPool|Promise}\n     */\n    value: function acquire(requester, callback) {\n      var _this2 = this;\n\n      if (typeof callback === 'function') {\n        this._acquire().then(function (connection) {\n          return callback(null, connection, _this2.config);\n        }).catch(callback);\n\n        return this;\n      }\n\n      return this._acquire();\n    }\n  }, {\n    key: \"_acquire\",\n    value: function _acquire() {\n      if (!this.pool) {\n        return Promise.reject(new ConnectionError('Connection not yet open.', 'ENOTOPEN'));\n      }\n\n      return this.pool.acquire();\n    }\n    /**\n     * Release connection back to the pool.\n     *\n     * @param {Connection} connection Previously acquired connection.\n     * @return {ConnectionPool}\n     */\n\n  }, {\n    key: \"release\",\n    value: function release(connection) {\n      debug('connection(%d): released', IDS.get(connection));\n\n      if (this.pool) {\n        this.pool.release(connection);\n      }\n\n      return this;\n    }\n    /**\n     * Creates a new connection pool with one active connection. This one initial connection serves as a probe to find out whether the configuration is valid.\n     *\n     * @param {basicCallback} [callback] A callback which is called after connection has established, or an error has occurred. If omited, method returns Promise.\n     * @return {ConnectionPool|Promise}\n     */\n\n  }, {\n    key: \"connect\",\n    value: function connect(callback) {\n      var _this3 = this;\n\n      if (typeof callback === 'function') {\n        this._connect(callback);\n\n        return this;\n      }\n\n      return new PromiseLibrary(function (resolve, reject) {\n        return _this3._connect(function (err) {\n          if (err) return reject(err);\n          resolve(_this3);\n        });\n      });\n    }\n    /**\n     * @private\n     * @param {basicCallback} callback\n     */\n\n  }, {\n    key: \"_connect\",\n    value: function _connect(callback) {\n      var _this4 = this;\n\n      if (this._connected) {\n        return callback(new ConnectionError('Database is already connected! Call close before connecting to different database.', 'EALREADYCONNECTED'));\n      }\n\n      if (this._connecting) {\n        return callback(new ConnectionError('Already connecting to database! Call close before connecting to different database.', 'EALREADYCONNECTING'));\n      }\n\n      this._connecting = true;\n      debug('pool(%d): connecting', IDS.get(this)); // create one test connection to check if everything is ok\n\n      this._poolCreate().then(function (connection) {\n        debug('pool(%d): connected', IDS.get(_this4));\n        return _this4._poolDestroy(connection).then(function () {\n          if (!_this4._connecting) {\n            debug('pool(%d): not connecting, exiting silently (was close called before connection established?)', IDS.get(_this4));\n            return;\n          } // prepare pool\n\n\n          _this4.pool = gp.createPool({\n            create: _this4._poolCreate.bind(_this4),\n            validate: _this4._poolValidate.bind(_this4),\n            destroy: _this4._poolDestroy.bind(_this4)\n          }, Object.assign({\n            max: 10,\n            min: 0,\n            evictionRunIntervalMillis: 1000,\n            idleTimeoutMillis: 30000,\n            testOnBorrow: true\n          }, _this4.config.pool));\n\n          _this4.pool.on('factoryCreateError', _this4.emit.bind(_this4, 'error'));\n\n          _this4.pool.on('factoryDestroyError', _this4.emit.bind(_this4, 'error'));\n\n          _this4._connecting = false;\n          _this4._connected = true;\n          callback(null);\n        });\n      }).catch(function (err) {\n        _this4._connecting = false;\n        callback(err);\n      });\n    }\n    /**\n     * Close all active connections in the pool.\n     *\n     * @param {basicCallback} [callback] A callback which is called after connection has closed, or an error has occurred. If omited, method returns Promise.\n     * @return {ConnectionPool|Promise}\n     */\n\n  }, {\n    key: \"close\",\n    value: function close(callback) {\n      var _this5 = this;\n\n      if (typeof callback === 'function') {\n        this._close(callback);\n\n        return this;\n      }\n\n      return new PromiseLibrary(function (resolve, reject) {\n        _this5._close(function (err) {\n          if (err) return reject(err);\n          resolve(_this5);\n        });\n      });\n    }\n    /**\n     * @private\n     * @param {basicCallback} callback\n     */\n\n  }, {\n    key: \"_close\",\n    value: function _close(callback) {\n      this._connecting = this._connected = false;\n      if (!this.pool) return setImmediate(callback, null);\n      var pool = this.pool;\n      this.pool.drain().then(function () {\n        pool.clear();\n        callback(null);\n      });\n      this.pool = null;\n    }\n    /**\n     * Returns new request using this connection.\n     *\n     * @return {Request}\n     */\n\n  }, {\n    key: \"request\",\n    value: function request() {\n      return new driver.Request(this);\n    }\n    /**\n     * Returns new transaction using this connection.\n     *\n     * @return {Transaction}\n     */\n\n  }, {\n    key: \"transaction\",\n    value: function transaction() {\n      return new driver.Transaction(this);\n    }\n    /**\n     * Creates a new query using this connection from a tagged template string.\n     *\n     * @variation 1\n     * @param {Array} strings Array of string literals.\n     * @param {...*} keys Values.\n     * @return {Request}\n     */\n\n    /**\n     * Execute the SQL command.\n     *\n     * @variation 2\n     * @param {String} command T-SQL command to be executed.\n     * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.\n     * @return {Request|Promise}\n     */\n\n  }, {\n    key: \"query\",\n    value: function query() {\n      if (typeof arguments[0] === 'string') {\n        return new driver.Request(this).query(arguments[0], arguments[1]);\n      }\n\n      var values = Array.prototype.slice.call(arguments);\n      var strings = values.shift();\n      return new driver.Request(this)._template(strings, values, 'query');\n    }\n    /**\n     * Creates a new batch using this connection from a tagged template string.\n     *\n     * @variation 1\n     * @param {Array} strings Array of string literals.\n     * @param {...*} keys Values.\n     * @return {Request}\n     */\n\n    /**\n     * Execute the SQL command.\n     *\n     * @variation 2\n     * @param {String} command T-SQL command to be executed.\n     * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.\n     * @return {Request|Promise}\n     */\n\n  }, {\n    key: \"batch\",\n    value: function batch() {\n      if (typeof arguments[0] === 'string') {\n        return new driver.Request(this).batch(arguments[0], arguments[1]);\n      }\n\n      var values = Array.prototype.slice.call(arguments);\n      var strings = values.shift();\n      return new driver.Request(this)._template(strings, values, 'batch');\n    }\n  }, {\n    key: \"connected\",\n    get: function get() {\n      return this._connected;\n    }\n  }, {\n    key: \"connecting\",\n    get: function get() {\n      return this._connecting;\n    }\n  }]);\n\n  return ConnectionPool;\n}(EventEmitter);\n/**\n * Class PreparedStatement.\n *\n * IMPORTANT: Rememeber that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement!\n *\n * @property {String} statement Prepared SQL statement.\n */\n\n\nvar PreparedStatement =\n/*#__PURE__*/\nfunction (_EventEmitter2) {\n  _inherits(PreparedStatement, _EventEmitter2);\n\n  /**\n   * Creates a new Prepared Statement.\n   *\n   * @param {ConnectionPool|Transaction} [holder]\n   */\n  function PreparedStatement(parent) {\n    var _this6;\n\n    _classCallCheck(this, PreparedStatement);\n\n    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(PreparedStatement).call(this));\n    IDS.add(_assertThisInitialized(_assertThisInitialized(_this6)), 'PreparedStatement');\n    debug('ps(%d): created', IDS.get(_assertThisInitialized(_assertThisInitialized(_this6))));\n    _this6.parent = parent || globalConnection;\n    _this6._handle = 0;\n    _this6.prepared = false;\n    _this6.parameters = {};\n    return _this6;\n  }\n\n  _createClass(PreparedStatement, [{\n    key: \"acquire\",\n\n    /**\n     * Acquire connection from connection pool.\n     *\n     * @param {Request} request Request.\n     * @param {ConnectionPool~acquireCallback} [callback] A callback which is called after connection has established, or an error has occurred. If omited, method returns Promise.\n     * @return {PreparedStatement|Promise}\n     */\n    value: function acquire(request, callback) {\n      if (!this._acquiredConnection) {\n        setImmediate(callback, new PreparedStatementError('Statement is not prepared. Call prepare() first.', 'ENOTPREPARED'));\n        return this;\n      }\n\n      if (this._activeRequest) {\n        setImmediate(callback, new TransactionError(\"Can't acquire connection for the request. There is another request in progress.\", 'EREQINPROG'));\n        return this;\n      }\n\n      this._activeRequest = request;\n      setImmediate(callback, null, this._acquiredConnection, this._acquiredConfig);\n      return this;\n    }\n    /**\n     * Release connection back to the pool.\n     *\n     * @param {Connection} connection Previously acquired connection.\n     * @return {PreparedStatement}\n     */\n\n  }, {\n    key: \"release\",\n    value: function release(connection) {\n      if (connection === this._acquiredConnection) {\n        this._activeRequest = null;\n      }\n\n      return this;\n    }\n    /**\n     * Add an input parameter to the prepared statement.\n     *\n     * @param {String} name Name of the input parameter without @ char.\n     * @param {*} type SQL data type of input parameter.\n     * @return {PreparedStatement}\n     */\n\n  }, {\n    key: \"input\",\n    value: function input(name, type) {\n      if (/(--| |\\/\\*|\\*\\/|')/.test(name)) {\n        throw new PreparedStatementError(\"SQL injection warning for param '\".concat(name, \"'\"), 'EINJECT');\n      }\n\n      if (arguments.length < 2) {\n        throw new PreparedStatementError('Invalid number of arguments. 2 arguments expected.', 'EARGS');\n      }\n\n      if (type instanceof Function) {\n        type = type();\n      }\n\n      this.parameters[name] = {\n        name: name,\n        type: type.type,\n        io: 1,\n        length: type.length,\n        scale: type.scale,\n        precision: type.precision,\n        tvpType: type.tvpType\n      };\n      return this;\n    }\n    /**\n     * Add an output parameter to the prepared statement.\n     *\n     * @param {String} name Name of the output parameter without @ char.\n     * @param {*} type SQL data type of output parameter.\n     * @return {PreparedStatement}\n     */\n\n  }, {\n    key: \"output\",\n    value: function output(name, type) {\n      if (/(--| |\\/\\*|\\*\\/|')/.test(name)) {\n        throw new PreparedStatementError(\"SQL injection warning for param '\".concat(name, \"'\"), 'EINJECT');\n      }\n\n      if (arguments.length < 2) {\n        throw new PreparedStatementError('Invalid number of arguments. 2 arguments expected.', 'EARGS');\n      }\n\n      if (type instanceof Function) type = type();\n      this.parameters[name] = {\n        name: name,\n        type: type.type,\n        io: 2,\n        length: type.length,\n        scale: type.scale,\n        precision: type.precision\n      };\n      return this;\n    }\n    /**\n     * Prepare a statement.\n     *\n     * @param {String} statement SQL statement to prepare.\n     * @param {basicCallback} [callback] A callback which is called after preparation has completed, or an error has occurred. If omited, method returns Promise.\n     * @return {PreparedStatement|Promise}\n     */\n\n  }, {\n    key: \"prepare\",\n    value: function prepare(statement, callback) {\n      var _this7 = this;\n\n      if (typeof callback === 'function') {\n        this._prepare(statement, callback);\n\n        return this;\n      }\n\n      return new PromiseLibrary(function (resolve, reject) {\n        _this7._prepare(statement, function (err) {\n          if (err) return reject(err);\n          resolve(_this7);\n        });\n      });\n    }\n    /**\n     * @private\n     * @param {String} statement\n     * @param {basicCallback} callback\n     */\n\n  }, {\n    key: \"_prepare\",\n    value: function _prepare(statement, callback) {\n      var _this8 = this;\n\n      debug('ps(%d): prepare', IDS.get(this));\n\n      if (typeof statement === 'function') {\n        callback = statement;\n        statement = undefined;\n      }\n\n      if (this.prepared) {\n        return setImmediate(callback, new PreparedStatementError('Statement is already prepared.', 'EALREADYPREPARED'));\n      }\n\n      this.statement = statement || this.statement;\n      this.parent.acquire(this, function (err, connection, config) {\n        if (err) return callback(err);\n        _this8._acquiredConnection = connection;\n        _this8._acquiredConfig = config;\n        var req = new driver.Request(_this8);\n        req.stream = false;\n        req.output('handle', TYPES.Int);\n        req.input('params', TYPES.NVarChar, function () {\n          var result = [];\n\n          for (var name in _this8.parameters) {\n            var param = _this8.parameters[name];\n            result.push(\"@\".concat(name, \" \").concat(declare(param.type, param)).concat(param.io === 2 ? ' output' : ''));\n          }\n\n          return result;\n        }().join(','));\n        req.input('stmt', TYPES.NVarChar, _this8.statement);\n        req.execute('sp_prepare', function (err, result) {\n          if (err) {\n            _this8.parent.release(_this8._acquiredConnection);\n\n            _this8._acquiredConnection = null;\n            _this8._acquiredConfig = null;\n            return callback(err);\n          }\n\n          debug('ps(%d): prepared', IDS.get(_this8));\n          _this8._handle = result.output.handle;\n          _this8.prepared = true;\n          callback(null);\n        });\n      });\n    }\n    /**\n     * Execute a prepared statement.\n     *\n     * @param {Object} values An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\n     * @param {basicCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.\n     * @return {Request|Promise}\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute(values, callback) {\n      var _this9 = this;\n\n      if (this.stream || typeof callback === 'function') {\n        return this._execute(values, callback);\n      }\n\n      return new PromiseLibrary(function (resolve, reject) {\n        _this9._execute(values, function (err, recordset) {\n          if (err) return reject(err);\n          resolve(recordset);\n        });\n      });\n    }\n    /**\n     * @private\n     * @param {Object} values\n     * @param {basicCallback} callback\n     */\n\n  }, {\n    key: \"_execute\",\n    value: function _execute(values, callback) {\n      var req = new driver.Request(this);\n      req.stream = this.stream;\n      req.input('handle', TYPES.Int, this._handle); // copy parameters with new values\n\n      for (var name in this.parameters) {\n        var param = this.parameters[name];\n        req.parameters[name] = {\n          name: name,\n          type: param.type,\n          io: param.io,\n          value: values[name],\n          length: param.length,\n          scale: param.scale,\n          precision: param.precision\n        };\n      }\n\n      req.execute('sp_execute', function (err, result) {\n        if (err) return callback(err);\n        callback(null, result);\n      });\n      return req;\n    }\n    /**\n     * Unprepare a prepared statement.\n     *\n     * @param {basicCallback} [callback] A callback which is called after unpreparation has completed, or an error has occurred. If omited, method returns Promise.\n     * @return {PreparedStatement|Promise}\n     */\n\n  }, {\n    key: \"unprepare\",\n    value: function unprepare(callback) {\n      var _this10 = this;\n\n      if (typeof callback === 'function') {\n        this._unprepare(callback);\n\n        return this;\n      }\n\n      return new PromiseLibrary(function (resolve, reject) {\n        _this10._unprepare(function (err) {\n          if (err) return reject(err);\n          resolve();\n        });\n      });\n    }\n    /**\n     * @private\n     * @param {basicCallback} callback\n     */\n\n  }, {\n    key: \"_unprepare\",\n    value: function _unprepare(callback) {\n      var _this11 = this;\n\n      debug('ps(%d): unprepare', IDS.get(this));\n\n      if (!this.prepared) {\n        return setImmediate(callback, new PreparedStatementError('Statement is not prepared. Call prepare() first.', 'ENOTPREPARED'));\n      }\n\n      if (this._activeRequest) {\n        return setImmediate(callback, new TransactionError(\"Can't unprepare the statement. There is a request in progress.\", 'EREQINPROG'));\n      }\n\n      var req = new driver.Request(this);\n      req.stream = false;\n      req.input('handle', TYPES.Int, this._handle);\n      req.execute('sp_unprepare', function (err) {\n        if (err) return callback(err);\n\n        _this11.parent.release(_this11._acquiredConnection);\n\n        _this11._acquiredConnection = null;\n        _this11._acquiredConfig = null;\n        _this11._handle = 0;\n        _this11.prepared = false;\n        debug('ps(%d): unprepared', IDS.get(_this11));\n        return callback(null);\n      });\n    }\n  }, {\n    key: \"connected\",\n    get: function get() {\n      return this.parent.connected;\n    }\n  }]);\n\n  return PreparedStatement;\n}(EventEmitter);\n/**\n * Class Transaction.\n *\n * @property {Number} isolationLevel Controls the locking and row versioning behavior of TSQL statements issued by a connection. READ_COMMITTED by default.\n * @property {String} name Transaction name. Empty string by default.\n *\n * @fires Transaction#begin\n * @fires Transaction#commit\n * @fires Transaction#rollback\n */\n\n\nvar Transaction =\n/*#__PURE__*/\nfunction (_EventEmitter3) {\n  _inherits(Transaction, _EventEmitter3);\n\n  /**\n   * Create new Transaction.\n   *\n   * @param {Connection} [holder] If ommited, global connection is used instead.\n   */\n  function Transaction(parent) {\n    var _this12;\n\n    _classCallCheck(this, Transaction);\n\n    _this12 = _possibleConstructorReturn(this, _getPrototypeOf(Transaction).call(this));\n    IDS.add(_assertThisInitialized(_assertThisInitialized(_this12)), 'Transaction');\n    debug('transaction(%d): created', IDS.get(_assertThisInitialized(_assertThisInitialized(_this12))));\n    _this12.parent = parent || globalConnection;\n    _this12.isolationLevel = ISOLATION_LEVEL.READ_COMMITTED;\n    _this12.name = '';\n    return _this12;\n  }\n\n  _createClass(Transaction, [{\n    key: \"acquire\",\n\n    /**\n     * Acquire connection from connection pool.\n     *\n     * @param {Request} request Request.\n     * @param {ConnectionPool~acquireCallback} [callback] A callback which is called after connection has established, or an error has occurred. If omited, method returns Promise.\n     * @return {Transaction|Promise}\n     */\n    value: function acquire(request, callback) {\n      if (!this._acquiredConnection) {\n        setImmediate(callback, new TransactionError('Transaction has not begun. Call begin() first.', 'ENOTBEGUN'));\n        return this;\n      }\n\n      if (this._activeRequest) {\n        setImmediate(callback, new TransactionError(\"Can't acquire connection for the request. There is another request in progress.\", 'EREQINPROG'));\n        return this;\n      }\n\n      this._activeRequest = request;\n      setImmediate(callback, null, this._acquiredConnection, this._acquiredConfig);\n      return this;\n    }\n    /**\n     * Release connection back to the pool.\n     *\n     * @param {Connection} connection Previously acquired connection.\n     * @return {Transaction}\n     */\n\n  }, {\n    key: \"release\",\n    value: function release(connection) {\n      if (connection === this._acquiredConnection) {\n        this._activeRequest = null;\n      }\n\n      return this;\n    }\n    /**\n     * Begin a transaction.\n     *\n     * @param {Number} [isolationLevel] Controls the locking and row versioning behavior of TSQL statements issued by a connection.\n     * @param {basicCallback} [callback] A callback which is called after transaction has began, or an error has occurred. If omited, method returns Promise.\n     * @return {Transaction|Promise}\n     */\n\n  }, {\n    key: \"begin\",\n    value: function begin(isolationLevel, callback) {\n      var _this13 = this;\n\n      if (isolationLevel instanceof Function) {\n        callback = isolationLevel;\n        isolationLevel = undefined;\n      }\n\n      if (typeof callback === 'function') {\n        this._begin(isolationLevel, function (err) {\n          if (!err) {\n            _this13.emit('begin');\n          }\n\n          callback(err);\n        });\n\n        return this;\n      }\n\n      return new PromiseLibrary(function (resolve, reject) {\n        _this13._begin(isolationLevel, function (err) {\n          if (err) return reject(err);\n\n          _this13.emit('begin');\n\n          resolve(_this13);\n        });\n      });\n    }\n    /**\n     * @private\n     * @param {Number} [isolationLevel]\n     * @param {basicCallback} [callback]\n     * @return {Transaction}\n     */\n\n  }, {\n    key: \"_begin\",\n    value: function _begin(isolationLevel, callback) {\n      if (this._acquiredConnection) {\n        return setImmediate(callback, new TransactionError('Transaction has already begun.', 'EALREADYBEGUN'));\n      }\n\n      this._aborted = false;\n      this._rollbackRequested = false;\n      this.isolationLevel = isolationLevel || this.isolationLevel;\n      setImmediate(callback);\n    }\n    /**\n     * Commit a transaction.\n     *\n     * @param {basicCallback} [callback] A callback which is called after transaction has commited, or an error has occurred. If omited, method returns Promise.\n     * @return {Transaction|Promise}\n     */\n\n  }, {\n    key: \"commit\",\n    value: function commit(callback) {\n      var _this14 = this;\n\n      if (typeof callback === 'function') {\n        this._commit(function (err) {\n          if (!err) {\n            _this14.emit('commit');\n          }\n\n          callback(err);\n        });\n\n        return this;\n      }\n\n      return new PromiseLibrary(function (resolve, reject) {\n        _this14._commit(function (err) {\n          if (err) return reject(err);\n\n          _this14.emit('commit');\n\n          resolve();\n        });\n      });\n    }\n    /**\n     * @private\n     * @param {basicCallback} [callback]\n     * @return {Transaction}\n     */\n\n  }, {\n    key: \"_commit\",\n    value: function _commit(callback) {\n      if (this._aborted) {\n        return setImmediate(callback, new TransactionError('Transaction has been aborted.', 'EABORT'));\n      }\n\n      if (!this._acquiredConnection) {\n        return setImmediate(callback, new TransactionError('Transaction has not begun. Call begin() first.', 'ENOTBEGUN'));\n      }\n\n      if (this._activeRequest) {\n        return setImmediate(callback, new TransactionError(\"Can't commit transaction. There is a request in progress.\", 'EREQINPROG'));\n      }\n\n      setImmediate(callback);\n    }\n    /**\n     * Returns new request using this transaction.\n     *\n     * @return {Request}\n     */\n\n  }, {\n    key: \"request\",\n    value: function request() {\n      return new driver.Request(this);\n    }\n    /**\n     * Rollback a transaction.\n     *\n     * @param {basicCallback} [callback] A callback which is called after transaction has rolled back, or an error has occurred. If omited, method returns Promise.\n     * @return {Transaction|Promise}\n     */\n\n  }, {\n    key: \"rollback\",\n    value: function rollback(callback) {\n      var _this15 = this;\n\n      if (typeof callback === 'function') {\n        this._rollback(function (err) {\n          if (!err) {\n            _this15.emit('rollback', _this15._aborted);\n          }\n\n          callback(err);\n        });\n\n        return this;\n      }\n\n      return new PromiseLibrary(function (resolve, reject) {\n        return _this15._rollback(function (err) {\n          if (err) return reject(err);\n\n          _this15.emit('rollback', _this15._aborted);\n\n          resolve();\n        });\n      });\n    }\n    /**\n     * @private\n     * @param {basicCallback} [callback]\n     * @return {Transaction}\n     */\n\n  }, {\n    key: \"_rollback\",\n    value: function _rollback(callback) {\n      if (this._aborted) {\n        return setImmediate(callback, new TransactionError('Transaction has been aborted.', 'EABORT'));\n      }\n\n      if (!this._acquiredConnection) {\n        return setImmediate(callback, new TransactionError('Transaction has not begun. Call begin() first.', 'ENOTBEGUN'));\n      }\n\n      if (this._activeRequest) {\n        return setImmediate(callback, new TransactionError(\"Can't rollback transaction. There is a request in progress.\", 'EREQINPROG'));\n      }\n\n      this._rollbackRequested = true;\n      setImmediate(callback);\n    }\n  }, {\n    key: \"connected\",\n    get: function get() {\n      return this.parent.connected;\n    }\n  }]);\n\n  return Transaction;\n}(EventEmitter);\n/**\n * Class Request.\n *\n * @property {Transaction} transaction Reference to transaction when request was created in transaction.\n * @property {*} parameters Collection of input and output parameters.\n * @property {Boolean} canceled `true` if request was canceled.\n *\n * @fires Request#recordset\n * @fires Request#row\n * @fires Request#done\n * @fires Request#error\n */\n\n\nvar Request =\n/*#__PURE__*/\nfunction (_EventEmitter4) {\n  _inherits(Request, _EventEmitter4);\n\n  /**\n   * Create new Request.\n   *\n   * @param {Connection|ConnectionPool|Transaction|PreparedStatement} parent If ommited, global connection is used instead.\n   */\n  function Request(parent) {\n    var _this16;\n\n    _classCallCheck(this, Request);\n\n    _this16 = _possibleConstructorReturn(this, _getPrototypeOf(Request).call(this));\n    IDS.add(_assertThisInitialized(_assertThisInitialized(_this16)), 'Request');\n    debug('request(%d): created', IDS.get(_assertThisInitialized(_assertThisInitialized(_this16))));\n    _this16.canceled = false;\n    _this16.parent = parent || globalConnection;\n    _this16.parameters = {};\n    return _this16;\n  }\n  /**\n   * Fetch request from tagged template string.\n   *\n   * @private\n   * @param {Array} strings\n   * @param {Array} values\n   * @param {String} [method] If provided, method is automtically called with serialized command on this object.\n   * @return {Request}\n   */\n\n\n  _createClass(Request, [{\n    key: \"_template\",\n    value: function _template(strings, values, method) {\n      var command = [strings[0]];\n\n      for (var index = 0; index < values.length; index++) {\n        var value = values[index]; // if value is an array, prepare each items as it's own comma separated parameter\n\n        if (Array.isArray(value)) {\n          for (var parameterIndex = 0; parameterIndex < value.length; parameterIndex++) {\n            this.input(\"param\".concat(index + 1, \"_\").concat(parameterIndex), value[parameterIndex]);\n            command.push(\"@param\".concat(index + 1, \"_\").concat(parameterIndex));\n\n            if (parameterIndex < value.length - 1) {\n              command.push(', ');\n            } else {\n              command.push(strings[index + 1]);\n            }\n          }\n        } else {\n          this.input(\"param\".concat(index + 1), value);\n          command.push(\"@param\".concat(index + 1), strings[index + 1]);\n        }\n      }\n\n      if (method) {\n        return this[method](command.join(''));\n      } else {\n        return command.join('');\n      }\n    }\n    /**\n     * Add an input parameter to the request.\n     *\n     * @param {String} name Name of the input parameter without @ char.\n     * @param {*} [type] SQL data type of input parameter. If you omit type, module automaticaly decide which SQL data type should be used based on JS data type.\n     * @param {*} value Input parameter value. `undefined` and `NaN` values are automatically converted to `null` values.\n     * @return {Request}\n     */\n\n  }, {\n    key: \"input\",\n    value: function input(name, type, value) {\n      if (/(--| |\\/\\*|\\*\\/|')/.test(name)) {\n        throw new RequestError(\"SQL injection warning for param '\".concat(name, \"'\"), 'EINJECT');\n      }\n\n      if (arguments.length === 1) {\n        throw new RequestError('Invalid number of arguments. At least 2 arguments expected.', 'EARGS');\n      } else if (arguments.length === 2) {\n        value = type;\n        type = getTypeByValue(value);\n      } // support for custom data types\n\n\n      if (value && typeof value.valueOf === 'function' && !(value instanceof Date)) value = value.valueOf();\n      if (value === undefined) value = null; // undefined to null\n\n      if (typeof value === 'number' && isNaN(value)) value = null; // NaN to null\n\n      if (type instanceof Function) type = type();\n      this.parameters[name] = {\n        name: name,\n        type: type.type,\n        io: 1,\n        value: value,\n        length: type.length,\n        scale: type.scale,\n        precision: type.precision,\n        tvpType: type.tvpType\n      };\n      return this;\n    }\n    /**\n     * Add an output parameter to the request.\n     *\n     * @param {String} name Name of the output parameter without @ char.\n     * @param {*} type SQL data type of output parameter.\n     * @param {*} [value] Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n     * @return {Request}\n     */\n\n  }, {\n    key: \"output\",\n    value: function output(name, type, value) {\n      if (!type) {\n        type = TYPES.NVarChar;\n      }\n\n      if (/(--| |\\/\\*|\\*\\/|')/.test(name)) {\n        throw new RequestError(\"SQL injection warning for param '\".concat(name, \"'\"), 'EINJECT');\n      }\n\n      if (type === TYPES.Text || type === TYPES.NText || type === TYPES.Image) {\n        throw new RequestError('Deprecated types (Text, NText, Image) are not supported as OUTPUT parameters.', 'EDEPRECATED');\n      } // support for custom data types\n\n\n      if (value && typeof value.valueOf === 'function' && !(value instanceof Date)) value = value.valueOf();\n      if (value === undefined) value = null; // undefined to null\n\n      if (typeof value === 'number' && isNaN(value)) value = null; // NaN to null\n\n      if (type instanceof Function) type = type();\n      this.parameters[name] = {\n        name: name,\n        type: type.type,\n        io: 2,\n        value: value,\n        length: type.length,\n        scale: type.scale,\n        precision: type.precision\n      };\n      return this;\n    }\n    /**\n     * Execute the SQL batch.\n     *\n     * @param {String} batch T-SQL batch to be executed.\n     * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.\n     * @return {Request|Promise}\n     */\n\n  }, {\n    key: \"batch\",\n    value: function batch(_batch, callback) {\n      var _this17 = this;\n\n      if (this.stream == null && this.connection) this.stream = this.connection.config.stream;\n      this.rowsAffected = 0;\n\n      if (typeof callback === 'function') {\n        this._batch(_batch, function (err, recordsets, output, rowsAffected) {\n          if (_this17.stream) {\n            if (err) _this17.emit('error', err);\n            err = null;\n\n            _this17.emit('done', {\n              output: output,\n              rowsAffected: rowsAffected\n            });\n          }\n\n          if (err) return callback(err);\n          callback(null, {\n            recordsets: recordsets,\n            recordset: recordsets && recordsets[0],\n            output: output,\n            rowsAffected: rowsAffected\n          });\n        });\n\n        return this;\n      } // Check is method was called as tagged template\n\n\n      if (typeof _batch === 'object') {\n        var values = Array.prototype.slice.call(arguments);\n        var strings = values.shift();\n        _batch = this._template(strings, values);\n      }\n\n      return new PromiseLibrary(function (resolve, reject) {\n        _this17._batch(_batch, function (err, recordsets, output, rowsAffected) {\n          if (_this17.stream) {\n            if (err) _this17.emit('error', err);\n            err = null;\n\n            _this17.emit('done', {\n              output: output,\n              rowsAffected: rowsAffected\n            });\n          }\n\n          if (err) return reject(err);\n          resolve({\n            recordsets: recordsets,\n            recordset: recordsets && recordsets[0],\n            output: output,\n            rowsAffected: rowsAffected\n          });\n        });\n      });\n    }\n    /**\n     * @private\n     * @param {String} batch\n     * @param {Request~requestCallback} callback\n     */\n\n  }, {\n    key: \"_batch\",\n    value: function _batch(batch, callback) {\n      if (!this.connection) {\n        return setImmediate(callback, new RequestError('No connection is specified for that request.', 'ENOCONN'));\n      }\n\n      if (!this.connection.connected) {\n        return setImmediate(callback, new ConnectionError('Connection is closed.', 'ECONNCLOSED'));\n      }\n\n      this.canceled = false;\n      setImmediate(callback);\n    }\n    /**\n     * Bulk load.\n     *\n     * @param {Table} table SQL table.\n     * @param {Request~bulkCallback} [callback] A callback which is called after bulk load has completed, or an error has occurred. If omited, method returns Promise.\n     * @return {Request|Promise}\n     */\n\n  }, {\n    key: \"bulk\",\n    value: function bulk(table, callback) {\n      var _this18 = this;\n\n      if (this.stream == null && this.connection) this.stream = this.connection.config.stream;\n\n      if (this.stream || typeof callback === 'function') {\n        this._bulk(table, function (err, rowsAffected) {\n          if (_this18.stream) {\n            if (err) _this18.emit('error', err);\n            return _this18.emit('done', {\n              rowsAffected: rowsAffected\n            });\n          }\n\n          if (err) return callback(err);\n          callback(null, {\n            rowsAffected: rowsAffected\n          });\n        });\n\n        return this;\n      }\n\n      return new PromiseLibrary(function (resolve, reject) {\n        _this18._bulk(table, function (err, rowsAffected) {\n          if (err) return reject(err);\n          resolve({\n            rowsAffected: rowsAffected\n          });\n        });\n      });\n    }\n    /**\n     * @private\n     * @param {Table} table\n     * @param {Request~bulkCallback} callback\n     */\n\n  }, {\n    key: \"_bulk\",\n    value: function _bulk(table, callback) {\n      if (!this.parent) {\n        return setImmediate(callback, new RequestError('No connection is specified for that request.', 'ENOCONN'));\n      }\n\n      if (!this.parent.connected) {\n        return setImmediate(callback, new ConnectionError('Connection is closed.', 'ECONNCLOSED'));\n      }\n\n      this.canceled = false;\n      setImmediate(callback);\n    }\n    /**\n     * Sets request to `stream` mode and pulls all rows from all recordsets to a given stream.\n     *\n     * @param {Stream} stream Stream to pipe data into.\n     * @return {Stream}\n     */\n\n  }, {\n    key: \"pipe\",\n    value: function pipe(stream) {\n      this.stream = true;\n      this.on('row', stream.write.bind(stream));\n      this.on('error', stream.emit.bind(stream, 'error'));\n      this.on('done', function () {\n        setImmediate(function () {\n          return stream.end();\n        });\n      });\n      stream.emit('pipe', this);\n      return stream;\n    }\n    /**\n     * Execute the SQL command.\n     *\n     * @param {String} command T-SQL command to be executed.\n     * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.\n     * @return {Request|Promise}\n     */\n\n  }, {\n    key: \"query\",\n    value: function query(command, callback) {\n      var _this19 = this;\n\n      if (this.stream == null && this.connection) this.stream = this.connection.config.stream;\n      this.rowsAffected = 0;\n\n      if (typeof callback === 'function') {\n        this._query(command, function (err, recordsets, output, rowsAffected) {\n          if (_this19.stream) {\n            if (err) _this19.emit('error', err);\n            err = null;\n\n            _this19.emit('done', {\n              output: output,\n              rowsAffected: rowsAffected\n            });\n          }\n\n          if (err) return callback(err);\n          callback(null, {\n            recordsets: recordsets,\n            recordset: recordsets && recordsets[0],\n            output: output,\n            rowsAffected: rowsAffected\n          });\n        });\n\n        return this;\n      } // Check is method was called as tagged template\n\n\n      if (typeof command === 'object') {\n        var values = Array.prototype.slice.call(arguments);\n        var strings = values.shift();\n        command = this._template(strings, values);\n      }\n\n      return new PromiseLibrary(function (resolve, reject) {\n        _this19._query(command, function (err, recordsets, output, rowsAffected) {\n          if (_this19.stream) {\n            if (err) _this19.emit('error', err);\n            err = null;\n\n            _this19.emit('done', {\n              output: output,\n              rowsAffected: rowsAffected\n            });\n          }\n\n          if (err) return reject(err);\n          resolve({\n            recordsets: recordsets,\n            recordset: recordsets && recordsets[0],\n            output: output,\n            rowsAffected: rowsAffected\n          });\n        });\n      });\n    }\n    /**\n     * @private\n     * @param {String} command\n     * @param {Request~bulkCallback} callback\n     */\n\n  }, {\n    key: \"_query\",\n    value: function _query(command, callback) {\n      if (!this.parent) {\n        return setImmediate(callback, new RequestError('No connection is specified for that request.', 'ENOCONN'));\n      }\n\n      if (!this.parent.connected) {\n        return setImmediate(callback, new ConnectionError('Connection is closed.', 'ECONNCLOSED'));\n      }\n\n      this.canceled = false;\n      setImmediate(callback);\n    }\n    /**\n     * Call a stored procedure.\n     *\n     * @param {String} procedure Name of the stored procedure to be executed.\n     * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.\n     * @return {Request|Promise}\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute(command, callback) {\n      var _this20 = this;\n\n      if (this.stream == null && this.connection) this.stream = this.connection.config.stream;\n      this.rowsAffected = 0;\n\n      if (typeof callback === 'function') {\n        this._execute(command, function (err, recordsets, output, returnValue, rowsAffected) {\n          if (_this20.stream) {\n            if (err) _this20.emit('error', err);\n            err = null;\n\n            _this20.emit('done', {\n              output: output,\n              rowsAffected: rowsAffected,\n              returnValue: returnValue\n            });\n          }\n\n          if (err) return callback(err);\n          callback(null, {\n            recordsets: recordsets,\n            recordset: recordsets && recordsets[0],\n            output: output,\n            rowsAffected: rowsAffected,\n            returnValue: returnValue\n          });\n        });\n\n        return this;\n      }\n\n      return new PromiseLibrary(function (resolve, reject) {\n        _this20._execute(command, function (err, recordsets, output, returnValue, rowsAffected) {\n          if (_this20.stream) {\n            if (err) _this20.emit('error', err);\n            err = null;\n\n            _this20.emit('done', {\n              output: output,\n              rowsAffected: rowsAffected,\n              returnValue: returnValue\n            });\n          }\n\n          if (err) return reject(err);\n          resolve({\n            recordsets: recordsets,\n            recordset: recordsets && recordsets[0],\n            output: output,\n            rowsAffected: rowsAffected,\n            returnValue: returnValue\n          });\n        });\n      });\n    }\n    /**\n     * @private\n     * @param {String} procedure\n     * @param {Request~bulkCallback} callback\n     */\n\n  }, {\n    key: \"_execute\",\n    value: function _execute(procedure, callback) {\n      if (!this.parent) {\n        return setImmediate(callback, new RequestError('No connection is specified for that request.', 'ENOCONN'));\n      }\n\n      if (!this.parent.connected) {\n        return setImmediate(callback, new ConnectionError('Connection is closed.', 'ECONNCLOSED'));\n      }\n\n      this.canceled = false;\n      setImmediate(callback);\n    }\n    /**\n     * Cancel currently executed request.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      this._cancel();\n\n      return true;\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_cancel\",\n    value: function _cancel() {\n      this.canceled = true;\n    }\n  }]);\n\n  return Request;\n}(EventEmitter);\n/**\n * Class ConnectionError.\n */\n\n\nvar ConnectionError =\n/*#__PURE__*/\nfunction (_Error) {\n  _inherits(ConnectionError, _Error);\n\n  /**\n   * Creates a new ConnectionError.\n   *\n   * @param {String} message Error message.\n   * @param {String} [code] Error code.\n   */\n  function ConnectionError(message, code) {\n    var _this21;\n\n    _classCallCheck(this, ConnectionError);\n\n    if (message instanceof Error) {\n      _this21 = _possibleConstructorReturn(this, _getPrototypeOf(ConnectionError).call(this, message.message));\n      _this21.code = message.code || code;\n      Error.captureStackTrace(_assertThisInitialized(_assertThisInitialized(_this21)), _this21.constructor);\n      Object.defineProperty(_assertThisInitialized(_assertThisInitialized(_this21)), 'originalError', {\n        enumerable: true,\n        value: message\n      });\n    } else {\n      _this21 = _possibleConstructorReturn(this, _getPrototypeOf(ConnectionError).call(this, message));\n      _this21.code = code;\n    }\n\n    _this21.name = 'ConnectionError';\n    return _possibleConstructorReturn(_this21);\n  }\n\n  return ConnectionError;\n}(_wrapNativeSuper(Error));\n/**\n * Class TransactionError.\n */\n\n\nvar TransactionError =\n/*#__PURE__*/\nfunction (_Error2) {\n  _inherits(TransactionError, _Error2);\n\n  /**\n   * Creates a new TransactionError.\n   *\n   * @param {String} message Error message.\n   * @param {String} [code] Error code.\n   */\n  function TransactionError(message, code) {\n    var _this22;\n\n    _classCallCheck(this, TransactionError);\n\n    if (message instanceof Error) {\n      _this22 = _possibleConstructorReturn(this, _getPrototypeOf(TransactionError).call(this, message.message));\n      _this22.code = message.code || code;\n      Error.captureStackTrace(_assertThisInitialized(_assertThisInitialized(_this22)), _this22.constructor);\n      Object.defineProperty(_assertThisInitialized(_assertThisInitialized(_this22)), 'originalError', {\n        enumerable: true,\n        value: message\n      });\n    } else {\n      _this22 = _possibleConstructorReturn(this, _getPrototypeOf(TransactionError).call(this, message));\n      _this22.code = code;\n    }\n\n    _this22.name = 'TransactionError';\n    return _possibleConstructorReturn(_this22);\n  }\n\n  return TransactionError;\n}(_wrapNativeSuper(Error));\n/**\n * Class RequestError.\n *\n * @property {String} number Error number.\n * @property {Number} lineNumber Line number.\n * @property {String} state Error state.\n * @property {String} class Error class.\n * @property {String} serverName Server name.\n * @property {String} procName Procedure name.\n */\n\n\nvar RequestError =\n/*#__PURE__*/\nfunction (_Error3) {\n  _inherits(RequestError, _Error3);\n\n  /**\n   * Creates a new RequestError.\n   *\n   * @param {String} message Error message.\n   * @param {String} [code] Error code.\n   */\n  function RequestError(message, code) {\n    var _this23;\n\n    _classCallCheck(this, RequestError);\n\n    if (message instanceof Error) {\n      _this23 = _possibleConstructorReturn(this, _getPrototypeOf(RequestError).call(this, message.message));\n      _this23.code = message.code || code;\n\n      if (message.info) {\n        _this23.number = message.info.number || message.code; // err.code is returned by msnodesql driver\n\n        _this23.lineNumber = message.info.lineNumber;\n        _this23.state = message.info.state || message.sqlstate; // err.sqlstate is returned by msnodesql driver\n\n        _this23.class = message.info.class;\n        _this23.serverName = message.info.serverName;\n        _this23.procName = message.info.procName;\n      } else {\n        _this23.number = message.code; // err.code is returned by msnodesql driver\n\n        _this23.state = message.sqlstate; // err.sqlstate is returned by msnodesql driver\n      }\n\n      Error.captureStackTrace(_assertThisInitialized(_assertThisInitialized(_this23)), _this23.constructor);\n      Object.defineProperty(_assertThisInitialized(_assertThisInitialized(_this23)), 'originalError', {\n        enumerable: true,\n        value: message\n      });\n    } else {\n      _this23 = _possibleConstructorReturn(this, _getPrototypeOf(RequestError).call(this, message));\n      _this23.code = code;\n    }\n\n    _this23.name = 'RequestError';\n\n    if (/^\\[Microsoft\\]\\[SQL Server Native Client 11\\.0\\](?:\\[SQL Server\\])?([\\s\\S]*)$/.exec(_this23.message)) {\n      _this23.message = RegExp.$1;\n    }\n\n    return _possibleConstructorReturn(_this23);\n  }\n\n  return RequestError;\n}(_wrapNativeSuper(Error));\n/**\n * Class PreparedStatementError.\n */\n\n\nvar PreparedStatementError =\n/*#__PURE__*/\nfunction (_Error4) {\n  _inherits(PreparedStatementError, _Error4);\n\n  /**\n   * Creates a new PreparedStatementError.\n   *\n   * @param {String} message Error message.\n   * @param {String} [code] Error code.\n   */\n  function PreparedStatementError(message, code) {\n    var _this24;\n\n    _classCallCheck(this, PreparedStatementError);\n\n    if (message instanceof Error) {\n      _this24 = _possibleConstructorReturn(this, _getPrototypeOf(PreparedStatementError).call(this, message.message));\n      _this24.code = message.code || code;\n      Error.captureStackTrace(_assertThisInitialized(_assertThisInitialized(_this24)), _this24.constructor);\n      Object.defineProperty(_assertThisInitialized(_assertThisInitialized(_this24)), 'originalError', {\n        enumerable: true,\n        value: message\n      });\n    } else {\n      _this24 = _possibleConstructorReturn(this, _getPrototypeOf(PreparedStatementError).call(this, message));\n      _this24.code = code;\n    }\n\n    _this24.name = 'PreparedStatementError';\n    return _possibleConstructorReturn(_this24);\n  }\n\n  return PreparedStatementError;\n}(_wrapNativeSuper(Error));\n\nmodule.exports = {\n  ConnectionPool: ConnectionPool,\n  Transaction: Transaction,\n  Request: Request,\n  PreparedStatement: PreparedStatement,\n  ConnectionError: ConnectionError,\n  TransactionError: TransactionError,\n  RequestError: RequestError,\n  PreparedStatementError: PreparedStatementError,\n  driver: driver,\n  exports: {\n    ConnectionError: ConnectionError,\n    TransactionError: TransactionError,\n    RequestError: RequestError,\n    PreparedStatementError: PreparedStatementError,\n    Table: Table,\n    ISOLATION_LEVEL: ISOLATION_LEVEL,\n    TYPES: TYPES,\n    MAX: 65535,\n    // (1 << 16) - 1\n    map: map,\n    getTypeByValue: getTypeByValue\n  }\n};\nObject.defineProperty(module.exports, 'Promise', {\n  get: function get() {\n    return PromiseLibrary;\n  },\n  set: function set(value) {\n    PromiseLibrary = value;\n  }\n}); // append datatypes to this modules export\n\nfor (var key in TYPES) {\n  var value = TYPES[key];\n  module.exports.exports[key] = value;\n  module.exports.exports[key.toUpperCase()] = value;\n}\n/**\n * Open global connection pool.\n *\n * @param {Object|String} config Connection configuration object or connection string.\n * @param {basicCallback} [callback] A callback which is called after connection has established, or an error has occurred. If omited, method returns Promise.\n * @return {ConnectionPool|Promise}\n */\n\n\nmodule.exports.exports.connect = function connect(config, callback) {\n  if (globalConnection) throw new Error('Global connection already exists. Call sql.close() first.');\n  globalConnection = new driver.ConnectionPool(config);\n\n  for (var event in globalConnectionHandlers) {\n    for (var i = 0, l = globalConnectionHandlers[event].length; i < l; i++) {\n      globalConnection.on(event, globalConnectionHandlers[event][i]);\n    }\n  }\n\n  return globalConnection.connect(callback);\n};\n/**\n * Close all active connections in the global pool.\n *\n * @param {basicCallback} [callback] A callback which is called after connection has closed, or an error has occurred. If omited, method returns Promise.\n * @return {ConnectionPool|Promise}\n */\n\n\nmodule.exports.exports.close = function close(callback) {\n  if (globalConnection) {\n    // remove event handlers from the global connection\n    for (var event in globalConnectionHandlers) {\n      for (var i = 0, l = globalConnectionHandlers[event].length; i < l; i++) {\n        globalConnection.removeListener(event, globalConnectionHandlers[event][i]);\n      }\n    } // attach error handler to prevent process crash in case of error\n\n\n    globalConnection.on('error', function (err) {\n      if (globalConnectionHandlers['error']) {\n        for (var _i4 = 0, _l = globalConnectionHandlers['error'].length; _i4 < _l; _i4++) {\n          globalConnectionHandlers['error'][_i4].call(globalConnection, err);\n        }\n      }\n    });\n    var gc = globalConnection;\n    globalConnection = null;\n    return gc.close(callback);\n  }\n\n  if (typeof callback === 'function') {\n    setImmediate(callback);\n    return null;\n  }\n\n  return new PromiseLibrary(function (resolve, reject) {\n    resolve(globalConnection);\n  });\n};\n/**\n * Attach event handler to global connection pool.\n *\n * @param {String} event Event name.\n * @param {Function} handler Event handler.\n * @return {ConnectionPool}\n */\n\n\nmodule.exports.exports.on = function on(event, handler) {\n  if (!globalConnectionHandlers[event]) globalConnectionHandlers[event] = [];\n  globalConnectionHandlers[event].push(handler);\n  if (globalConnection) globalConnection.on(event, handler);\n  return globalConnection;\n};\n/**\n * Detach event handler from global connection.\n *\n * @param {String} event Event name.\n * @param {Function} handler Event handler.\n * @return {ConnectionPool}\n */\n\n\nmodule.exports.exports.removeListener = module.exports.exports.off = function removeListener(event, handler) {\n  if (!globalConnectionHandlers[event]) return globalConnection;\n  var index = globalConnectionHandlers[event].indexOf(handler);\n  if (index === -1) return globalConnection;\n  globalConnectionHandlers[event].splice(index, 1);\n  if (globalConnectionHandlers[event].length === 0) globalConnectionHandlers[event] = undefined;\n  if (globalConnection) globalConnection.removeListener(event, handler);\n  return globalConnection;\n};\n/**\n * Creates a new query using global connection from a tagged template string.\n *\n * @variation 1\n * @param {Array|String} strings Array of string literals or sql command.\n * @param {...*} keys Values.\n * @return {Request}\n */\n\n/**\n * Execute the SQL command.\n *\n * @variation 2\n * @param {String} command T-SQL command to be executed.\n * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.\n * @return {Request|Promise}\n */\n\n\nmodule.exports.exports.query = function query() {\n  if (typeof arguments[0] === 'string') {\n    return new driver.Request().query(arguments[0], arguments[1]);\n  }\n\n  var values = Array.prototype.slice.call(arguments);\n  var strings = values.shift();\n  return new driver.Request()._template(strings, values, 'query');\n};\n/**\n * Creates a new batch using global connection from a tagged template string.\n *\n * @variation 1\n * @param {Array} strings Array of string literals.\n * @param {...*} keys Values.\n * @return {Request}\n */\n\n/**\n * Execute the SQL command.\n *\n * @variation 2\n * @param {String} command T-SQL command to be executed.\n * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.\n * @return {Request|Promise}\n */\n\n\nmodule.exports.exports.batch = function batch() {\n  if (typeof arguments[0] === 'string') {\n    return new driver.Request().batch(arguments[0], arguments[1]);\n  }\n\n  var values = Array.prototype.slice.call(arguments);\n  var strings = values.shift();\n  return new driver.Request()._template(strings, values, 'batch');\n};\n/**\n * @callback Request~requestCallback\n * @param {Error} err Error on error, otherwise null.\n * @param {Object} result Request result.\n */\n\n/**\n * @callback Request~bulkCallback\n * @param {Error} err Error on error, otherwise null.\n * @param {Number} rowsAffected Number of affected rows.\n */\n\n/**\n * @callback basicCallback\n * @param {Error} err Error on error, otherwise null.\n * @param {Connection} connection Acquired connection.\n */\n\n/**\n * @callback acquireCallback\n * @param {Error} err Error on error, otherwise null.\n * @param {Connection} connection Acquired connection.\n */\n\n/**\n * Dispatched after connection has established.\n * @event ConnectionPool#connect\n */\n\n/**\n * Dispatched after connection has closed a pool (by calling close).\n * @event ConnectionPool#close\n */\n\n/**\n * Dispatched when transaction begin.\n * @event Transaction#begin\n */\n\n/**\n * Dispatched on successful commit.\n * @event Transaction#commit\n */\n\n/**\n * Dispatched on successful rollback.\n * @event Transaction#rollback\n */\n\n/**\n * Dispatched when metadata for new recordset are parsed.\n * @event Request#recordset\n */\n\n/**\n * Dispatched when new row is parsed.\n * @event Request#row\n */\n\n/**\n * Dispatched when request is complete.\n * @event Request#done\n */\n\n/**\n * Dispatched on error.\n * @event Request#error\n */","map":null,"metadata":{},"sourceType":"script"}