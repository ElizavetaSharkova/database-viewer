{"ast":null,"code":"'use strict';\n\nvar _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar BufferList = require('bl');\n\nvar _require = require('readable-stream'),\n    Transform = _require.Transform;\n\nvar Message = require('./message');\n\nvar _require2 = require('./packet'),\n    Packet = _require2.Packet,\n    HEADER_LENGTH = _require2.HEADER_LENGTH;\n/**\n  IncomingMessageStream\n  Transform received TDS data into individual IncomingMessage streams.\n*/\n\n\nvar IncomingMessageStream = function (_Transform) {\n  (0, _inherits3.default)(IncomingMessageStream, _Transform);\n\n  function IncomingMessageStream(debug) {\n    (0, _classCallCheck3.default)(this, IncomingMessageStream);\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (IncomingMessageStream.__proto__ || (0, _getPrototypeOf2.default)(IncomingMessageStream)).call(this, {\n      readableObjectMode: true\n    }));\n\n    _this.debug = debug;\n    _this.currentMessage = undefined;\n    _this.bl = new BufferList();\n    return _this;\n  }\n\n  (0, _createClass3.default)(IncomingMessageStream, [{\n    key: 'processBufferedData',\n    value: function processBufferedData(callback) {\n      var _this2 = this; // The packet header is always 8 bytes of length.\n\n\n      while (this.bl.length >= HEADER_LENGTH) {\n        // Get the full packet length\n        var length = this.bl.readUInt16BE(2);\n\n        if (this.bl.length >= length) {\n          var data = this.bl.slice(0, length);\n          this.bl.consume(length); // TODO: Get rid of creating `Packet` instances here.\n\n          var packet = new Packet(data);\n          this.debug.packet('Received', packet);\n          this.debug.data(packet);\n          var message = this.currentMessage;\n\n          if (message === undefined) {\n            message = new Message({\n              type: packet.type(),\n              resetConnection: false\n            });\n            this.push(message);\n          }\n\n          if (packet.isLast()) {\n            this.currentMessage = undefined; // Wait until the current message was fully processed before we\n            // continue processing any remaining messages.\n\n            message.once('end', function () {\n              _this2.processBufferedData(callback);\n            });\n            message.end(packet.data());\n            return;\n          } else {\n            this.currentMessage = message; // If too much data is buffering up in the\n            // current message, wait for it to drain.\n\n            if (!message.write(packet.data())) {\n              message.once('drain', function () {\n                _this2.processBufferedData(callback);\n              });\n              return;\n            }\n          }\n        } else {\n          break;\n        }\n      } // Not enough data to read the next packet. Stop here and wait for\n      // the next call to `_transform`.\n\n\n      callback();\n    }\n  }, {\n    key: '_transform',\n    value: function _transform(chunk, encoding, callback) {\n      this.bl.append(chunk);\n      this.processBufferedData(callback);\n    }\n  }]);\n  return IncomingMessageStream;\n}(Transform);\n\nmodule.exports = IncomingMessageStream;","map":null,"metadata":{},"sourceType":"script"}