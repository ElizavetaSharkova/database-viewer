{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\elizaveta.sharkova\\\\Learning\\\\React\\\\First\\\\database-viewer\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\elizaveta.sharkova\\\\Learning\\\\React\\\\First\\\\database-viewer\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\elizaveta.sharkova\\\\Learning\\\\React\\\\First\\\\database-viewer\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\elizaveta.sharkova\\\\Learning\\\\React\\\\First\\\\database-viewer\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\elizaveta.sharkova\\\\Learning\\\\React\\\\First\\\\database-viewer\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar EventEmitter = require(\"events\").EventEmitter;\n\nvar factoryValidator = require(\"./factoryValidator\");\n\nvar PoolOptions = require(\"./PoolOptions\");\n\nvar ResourceRequest = require(\"./ResourceRequest\");\n\nvar ResourceLoan = require(\"./ResourceLoan\");\n\nvar PooledResource = require(\"./PooledResource\");\n\nvar DefaultEvictor = require(\"./DefaultEvictor\");\n\nvar Deque = require(\"./Deque\");\n\nvar Deferred = require(\"./Deferred\");\n\nvar PriorityQueue = require(\"./PriorityQueue\");\n\nvar DequeIterator = require(\"./DequeIterator\");\n\nvar reflector = require(\"./utils\").reflector;\n/**\n * TODO: move me\n */\n\n\nvar FACTORY_CREATE_ERROR = \"factoryCreateError\";\nvar FACTORY_DESTROY_ERROR = \"factoryDestroyError\";\n\nvar Pool =\n/*#__PURE__*/\nfunction (_EventEmitter) {\n  _inherits(Pool, _EventEmitter);\n\n  /**\n   * Generate an Object pool with a specified `factory` and `config`.\n   *\n   * @param {typeof DefaultEvictor} Evictor\n   * @param {typeof Deque} Deque\n   * @param {typeof PriorityQueue} PriorityQueue\n   * @param {Object} factory\n   *   Factory to be used for generating and destroying the items.\n   * @param {Function} factory.create\n   *   Should create the item to be acquired,\n   *   and call it's first callback argument with the generated item as it's argument.\n   * @param {Function} factory.destroy\n   *   Should gently close any resources that the item is using.\n   *   Called before the items is destroyed.\n   * @param {Function} factory.validate\n   *   Test if a resource is still valid .Should return a promise that resolves to a boolean, true if resource is still valid and false\n   *   If it should be removed from pool.\n   * @param {Object} options\n   */\n  function Pool(Evictor, Deque, PriorityQueue, factory, options) {\n    var _this;\n\n    _classCallCheck(this, Pool);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Pool).call(this));\n    factoryValidator(factory);\n    _this._config = new PoolOptions(options); // TODO: fix up this ugly glue-ing\n\n    _this._Promise = _this._config.Promise;\n    _this._factory = factory;\n    _this._draining = false;\n    _this._started = false;\n    /**\n     * Holds waiting clients\n     * @type {PriorityQueue}\n     */\n\n    _this._waitingClientsQueue = new PriorityQueue(_this._config.priorityRange);\n    /**\n     * Collection of promises for resource creation calls made by the pool to factory.create\n     * @type {Set}\n     */\n\n    _this._factoryCreateOperations = new Set();\n    /**\n     * Collection of promises for resource destruction calls made by the pool to factory.destroy\n     * @type {Set}\n     */\n\n    _this._factoryDestroyOperations = new Set();\n    /**\n     * A queue/stack of pooledResources awaiting acquisition\n     * TODO: replace with LinkedList backed array\n     * @type {Deque}\n     */\n\n    _this._availableObjects = new Deque();\n    /**\n     * Collection of references for any resource that are undergoing validation before being acquired\n     * @type {Set}\n     */\n\n    _this._testOnBorrowResources = new Set();\n    /**\n     * Collection of references for any resource that are undergoing validation before being returned\n     * @type {Set}\n     */\n\n    _this._testOnReturnResources = new Set();\n    /**\n     * Collection of promises for any validations currently in process\n     * @type {Set}\n     */\n\n    _this._validationOperations = new Set();\n    /**\n     * All objects associated with this pool in any state (except destroyed)\n     * @type {Set}\n     */\n\n    _this._allObjects = new Set();\n    /**\n     * Loans keyed by the borrowed resource\n     * @type {Map}\n     */\n\n    _this._resourceLoans = new Map();\n    /**\n     * Infinitely looping iterator over available object\n     * @type {DequeIterator}\n     */\n\n    _this._evictionIterator = _this._availableObjects.iterator();\n    _this._evictor = new Evictor();\n    /**\n     * handle for setTimeout for next eviction run\n     * @type {(number|null)}\n     */\n\n    _this._scheduledEviction = null; // create initial resources (if factory.min > 0)\n\n    if (_this._config.autostart === true) {\n      _this.start();\n    }\n\n    return _this;\n  }\n\n  _createClass(Pool, [{\n    key: \"_destroy\",\n    value: function _destroy(pooledResource) {\n      var _this2 = this;\n\n      // FIXME: do we need another state for \"in destruction\"?\n      pooledResource.invalidate();\n\n      this._allObjects.delete(pooledResource); // NOTE: this maybe very bad promise usage?\n\n\n      var destroyPromise = this._factory.destroy(pooledResource.obj);\n\n      var wrappedDestroyPromise = this._Promise.resolve(destroyPromise);\n\n      this._trackOperation(wrappedDestroyPromise, this._factoryDestroyOperations).catch(function (reason) {\n        _this2.emit(FACTORY_DESTROY_ERROR, reason);\n      }); // TODO: maybe ensuring minimum pool size should live outside here\n\n\n      this._ensureMinimum();\n    }\n    /**\n     * Attempt to move an available resource into test and then onto a waiting client\n     * @return {Boolean} could we move an available resource into test\n     */\n\n  }, {\n    key: \"_testOnBorrow\",\n    value: function _testOnBorrow() {\n      var _this3 = this;\n\n      if (this._availableObjects.length < 1) {\n        return false;\n      }\n\n      var pooledResource = this._availableObjects.shift(); // Mark the resource as in test\n\n\n      pooledResource.test();\n\n      this._testOnBorrowResources.add(pooledResource);\n\n      var validationPromise = this._factory.validate(pooledResource.obj);\n\n      var wrappedValidationPromise = this._Promise.resolve(validationPromise);\n\n      this._trackOperation(wrappedValidationPromise, this._validationOperations).then(function (isValid) {\n        _this3._testOnBorrowResources.delete(pooledResource);\n\n        if (isValid === false) {\n          pooledResource.invalidate();\n\n          _this3._destroy(pooledResource);\n\n          _this3._dispense();\n\n          return;\n        }\n\n        _this3._dispatchPooledResourceToNextWaitingClient(pooledResource);\n      });\n\n      return true;\n    }\n    /**\n     * Attempt to move an available resource to a waiting client\n     * @return {Boolean} [description]\n     */\n\n  }, {\n    key: \"_dispatchResource\",\n    value: function _dispatchResource() {\n      if (this._availableObjects.length < 1) {\n        return false;\n      }\n\n      var pooledResource = this._availableObjects.shift();\n\n      this._dispatchPooledResourceToNextWaitingClient(pooledResource);\n\n      return false;\n    }\n    /**\n     * Attempt to resolve an outstanding resource request using an available resource from\n     * the pool, or creating new ones\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_dispense\",\n    value: function _dispense() {\n      /**\n       * Local variables for ease of reading/writing\n       * these don't (shouldn't) change across the execution of this fn\n       */\n      var numWaitingClients = this._waitingClientsQueue.length; // If there aren't any waiting requests then there is nothing to do\n      // so lets short-circuit\n\n      if (numWaitingClients < 1) {\n        return;\n      }\n\n      var resourceShortfall = numWaitingClients - this._potentiallyAllocableResourceCount;\n      var actualNumberOfResourcesToCreate = Math.min(this.spareResourceCapacity, resourceShortfall);\n\n      for (var i = 0; actualNumberOfResourcesToCreate > i; i++) {\n        this._createResource();\n      } // If we are doing test-on-borrow see how many more resources need to be moved into test\n      // to help satisfy waitingClients\n\n\n      if (this._config.testOnBorrow === true) {\n        // how many available resources do we need to shift into test\n        var desiredNumberOfResourcesToMoveIntoTest = numWaitingClients - this._testOnBorrowResources.size;\n        var actualNumberOfResourcesToMoveIntoTest = Math.min(this._availableObjects.length, desiredNumberOfResourcesToMoveIntoTest);\n\n        for (var _i = 0; actualNumberOfResourcesToMoveIntoTest > _i; _i++) {\n          this._testOnBorrow();\n        }\n      } // if we aren't testing-on-borrow then lets try to allocate what we can\n\n\n      if (this._config.testOnBorrow === false) {\n        var actualNumberOfResourcesToDispatch = Math.min(this._availableObjects.length, numWaitingClients);\n\n        for (var _i2 = 0; actualNumberOfResourcesToDispatch > _i2; _i2++) {\n          this._dispatchResource();\n        }\n      }\n    }\n    /**\n     * Dispatches a pooledResource to the next waiting client (if any) else\n     * puts the PooledResource back on the available list\n     * @param  {PooledResource} pooledResource [description]\n     * @return {Boolean}                [description]\n     */\n\n  }, {\n    key: \"_dispatchPooledResourceToNextWaitingClient\",\n    value: function _dispatchPooledResourceToNextWaitingClient(pooledResource) {\n      var clientResourceRequest = this._waitingClientsQueue.dequeue();\n\n      if (clientResourceRequest === undefined || clientResourceRequest.state !== Deferred.PENDING) {\n        // While we were away either all the waiting clients timed out\n        // or were somehow fulfilled. put our pooledResource back.\n        this._addPooledResourceToAvailableObjects(pooledResource); // TODO: do need to trigger anything before we leave?\n\n\n        return false;\n      }\n\n      var loan = new ResourceLoan(pooledResource, this._Promise);\n\n      this._resourceLoans.set(pooledResource.obj, loan);\n\n      pooledResource.allocate();\n      clientResourceRequest.resolve(pooledResource.obj);\n      return true;\n    }\n    /**\n     * tracks on operation using given set\n     * handles adding/removing from the set and resolve/rejects the value/reason\n     * @param  {Promise} operation\n     * @param  {Set} set       Set holding operations\n     * @return {Promise}       Promise that resolves once operation has been removed from set\n     */\n\n  }, {\n    key: \"_trackOperation\",\n    value: function _trackOperation(operation, set) {\n      var _this4 = this;\n\n      set.add(operation);\n      return operation.then(function (v) {\n        set.delete(operation);\n        return _this4._Promise.resolve(v);\n      }, function (e) {\n        set.delete(operation);\n        return _this4._Promise.reject(e);\n      });\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_createResource\",\n    value: function _createResource() {\n      var _this5 = this;\n\n      // An attempt to create a resource\n      var factoryPromise = this._factory.create();\n\n      var wrappedFactoryPromise = this._Promise.resolve(factoryPromise).then(function (resource) {\n        var pooledResource = new PooledResource(resource);\n\n        _this5._allObjects.add(pooledResource);\n\n        _this5._addPooledResourceToAvailableObjects(pooledResource);\n      });\n\n      this._trackOperation(wrappedFactoryPromise, this._factoryCreateOperations).then(function () {\n        _this5._dispense(); // Stop bluebird complaining about this side-effect only handler\n        // - a promise was created in a handler but was not returned from it\n        // https://goo.gl/rRqMUw\n\n\n        return null;\n      }).catch(function (reason) {\n        _this5.emit(FACTORY_CREATE_ERROR, reason);\n\n        _this5._dispense();\n      });\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_ensureMinimum\",\n    value: function _ensureMinimum() {\n      if (this._draining === true) {\n        return;\n      }\n\n      var minShortfall = this._config.min - this._count;\n\n      for (var i = 0; i < minShortfall; i++) {\n        this._createResource();\n      }\n    }\n  }, {\n    key: \"_evict\",\n    value: function _evict() {\n      var testsToRun = Math.min(this._config.numTestsPerEvictionRun, this._availableObjects.length);\n      var evictionConfig = {\n        softIdleTimeoutMillis: this._config.softIdleTimeoutMillis,\n        idleTimeoutMillis: this._config.idleTimeoutMillis,\n        min: this._config.min\n      };\n\n      for (var testsHaveRun = 0; testsHaveRun < testsToRun;) {\n        var iterationResult = this._evictionIterator.next(); // Safety check incase we could get stuck in infinite loop because we\n        // somehow emptied the array after chekcing it's length\n\n\n        if (iterationResult.done === true && this._availableObjects.length < 1) {\n          this._evictionIterator.reset();\n\n          return;\n        } // if this happens it should just mean we reached the end of the\n        // list and can reset the cursor.\n\n\n        if (iterationResult.done === true && this._availableObjects.length > 0) {\n          this._evictionIterator.reset();\n\n          continue;\n        }\n\n        var resource = iterationResult.value;\n\n        var shouldEvict = this._evictor.evict(evictionConfig, resource, this._availableObjects.length);\n\n        testsHaveRun++;\n\n        if (shouldEvict === true) {\n          // take it out of the _availableObjects list\n          this._evictionIterator.remove();\n\n          this._destroy(resource);\n        }\n      }\n    }\n  }, {\n    key: \"_scheduleEvictorRun\",\n    value: function _scheduleEvictorRun() {\n      var _this6 = this;\n\n      // Start eviction if set\n      if (this._config.evictionRunIntervalMillis > 0) {\n        // @ts-ignore\n        this._scheduledEviction = setTimeout(function () {\n          _this6._evict();\n\n          _this6._scheduleEvictorRun();\n        }, this._config.evictionRunIntervalMillis);\n      }\n    }\n  }, {\n    key: \"_descheduleEvictorRun\",\n    value: function _descheduleEvictorRun() {\n      if (this._scheduledEviction) {\n        clearTimeout(this._scheduledEviction);\n      }\n\n      this._scheduledEviction = null;\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      if (this._draining === true) {\n        return;\n      }\n\n      if (this._started === true) {\n        return;\n      }\n\n      this._started = true;\n\n      this._scheduleEvictorRun();\n\n      this._ensureMinimum();\n    }\n    /**\n     * Request a new resource. The callback will be called,\n     * when a new resource is available, passing the resource to the callback.\n     * TODO: should we add a seperate \"acquireWithPriority\" function\n     *\n     * @param {Number} [priority=0]\n     *   Optional.  Integer between 0 and (priorityRange - 1).  Specifies the priority\n     *   of the caller if there are no available resources.  Lower numbers mean higher\n     *   priority.\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"acquire\",\n    value: function acquire(priority) {\n      if (this._started === false && this._config.autostart === false) {\n        this.start();\n      }\n\n      if (this._draining) {\n        return this._Promise.reject(new Error(\"pool is draining and cannot accept work\"));\n      } // TODO: should we defer this check till after this event loop incase \"the situation\" changes in the meantime\n\n\n      if (this.spareResourceCapacity < 1 && this._availableObjects.length < 1 && this._config.maxWaitingClients !== undefined && this._waitingClientsQueue.length >= this._config.maxWaitingClients) {\n        return this._Promise.reject(new Error(\"max waitingClients count exceeded\"));\n      }\n\n      var resourceRequest = new ResourceRequest(this._config.acquireTimeoutMillis, this._Promise);\n\n      this._waitingClientsQueue.enqueue(resourceRequest, priority);\n\n      this._dispense();\n\n      return resourceRequest.promise;\n    }\n    /**\n     * [use method, aquires a resource, passes the resource to a user supplied function and releases it]\n     * @param  {Function} fn [a function that accepts a resource and returns a promise that resolves/rejects once it has finished using the resource]\n     * @return {Promise}      [resolves once the resource is released to the pool]\n     */\n\n  }, {\n    key: \"use\",\n    value: function use(fn) {\n      var _this7 = this;\n\n      return this.acquire().then(function (resource) {\n        return fn(resource).then(function (result) {\n          _this7.release(resource);\n\n          return result;\n        }, function (err) {\n          _this7.release(resource);\n\n          throw err;\n        });\n      });\n    }\n    /**\n     * Check if resource is currently on loan from the pool\n     *\n     * @param {Function} resource\n     *    Resource for checking.\n     *\n     * @returns {Boolean}\n     *  True if resource belongs to this pool and false otherwise\n     */\n\n  }, {\n    key: \"isBorrowedResource\",\n    value: function isBorrowedResource(resource) {\n      return this._resourceLoans.has(resource);\n    }\n    /**\n     * Return the resource to the pool when it is no longer required.\n     *\n     * @param {Object} resource\n     *   The acquired object to be put back to the pool.\n     */\n\n  }, {\n    key: \"release\",\n    value: function release(resource) {\n      // check for an outstanding loan\n      var loan = this._resourceLoans.get(resource);\n\n      if (loan === undefined) {\n        return this._Promise.reject(new Error(\"Resource not currently part of this pool\"));\n      }\n\n      this._resourceLoans.delete(resource);\n\n      loan.resolve();\n      var pooledResource = loan.pooledResource;\n      pooledResource.deallocate();\n\n      this._addPooledResourceToAvailableObjects(pooledResource);\n\n      this._dispense();\n\n      return this._Promise.resolve();\n    }\n    /**\n     * Request the resource to be destroyed. The factory's destroy handler\n     * will also be called.\n     *\n     * This should be called within an acquire() block as an alternative to release().\n     *\n     * @param {Object} resource\n     *   The acquired resource to be destoyed.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy(resource) {\n      // check for an outstanding loan\n      var loan = this._resourceLoans.get(resource);\n\n      if (loan === undefined) {\n        return this._Promise.reject(new Error(\"Resource not currently part of this pool\"));\n      }\n\n      this._resourceLoans.delete(resource);\n\n      loan.resolve();\n      var pooledResource = loan.pooledResource;\n      pooledResource.deallocate();\n\n      this._destroy(pooledResource);\n\n      this._dispense();\n\n      return this._Promise.resolve();\n    }\n  }, {\n    key: \"_addPooledResourceToAvailableObjects\",\n    value: function _addPooledResourceToAvailableObjects(pooledResource) {\n      pooledResource.idle();\n\n      if (this._config.fifo === true) {\n        this._availableObjects.push(pooledResource);\n      } else {\n        this._availableObjects.unshift(pooledResource);\n      }\n    }\n    /**\n     * Disallow any new acquire calls and let the request backlog dissapate.\n     * The Pool will no longer attempt to maintain a \"min\" number of resources\n     * and will only make new resources on demand.\n     * Resolves once all resource requests are fulfilled and all resources are returned to pool and available...\n     * Should probably be called \"drain work\"\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"drain\",\n    value: function drain() {\n      var _this8 = this;\n\n      this._draining = true;\n      return this.__allResourceRequestsSettled().then(function () {\n        return _this8.__allResourcesReturned();\n      }).then(function () {\n        _this8._descheduleEvictorRun();\n      });\n    }\n  }, {\n    key: \"__allResourceRequestsSettled\",\n    value: function __allResourceRequestsSettled() {\n      if (this._waitingClientsQueue.length > 0) {\n        // wait for last waiting client to be settled\n        // FIXME: what if they can \"resolve\" out of order....?\n        return reflector(this._waitingClientsQueue.tail.promise);\n      }\n\n      return this._Promise.resolve();\n    } // FIXME: this is a horrific mess\n\n  }, {\n    key: \"__allResourcesReturned\",\n    value: function __allResourcesReturned() {\n      var ps = Array.from(this._resourceLoans.values()).map(function (loan) {\n        return loan.promise;\n      }).map(reflector);\n      return this._Promise.all(ps);\n    }\n    /**\n     * Forcibly destroys all available resources regardless of timeout.  Intended to be\n     * invoked as part of a drain.  Does not prevent the creation of new\n     * resources as a result of subsequent calls to acquire.\n     *\n     * Note that if factory.min > 0 and the pool isn't \"draining\", the pool will destroy all idle resources\n     * in the pool, but replace them with newly created resources up to the\n     * specified factory.min value.  If this is not desired, set factory.min\n     * to zero before calling clear()\n     *\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var _this9 = this;\n\n      var reflectedCreatePromises = Array.from(this._factoryCreateOperations).map(reflector); // wait for outstanding factory.create to complete\n\n      return this._Promise.all(reflectedCreatePromises).then(function () {\n        // Destroy existing resources\n        // @ts-ignore\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = _this9._availableObjects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var resource = _step.value;\n\n            _this9._destroy(resource);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        var reflectedDestroyPromises = Array.from(_this9._factoryDestroyOperations).map(reflector);\n        return reflector(_this9._Promise.all(reflectedDestroyPromises));\n      });\n    }\n    /**\n     * How many resources are available to allocated\n     * (includes resources that have not been tested and may faul validation)\n     * NOTE: internal for now as the name is awful and might not be useful to anyone\n     * @return {Number} number of resources the pool has to allocate\n     */\n\n  }, {\n    key: \"_potentiallyAllocableResourceCount\",\n    get: function get() {\n      return this._availableObjects.length + this._testOnBorrowResources.size + this._testOnReturnResources.size + this._factoryCreateOperations.size;\n    }\n    /**\n     * The combined count of the currently created objects and those in the\n     * process of being created\n     * Does NOT include resources in the process of being destroyed\n     * sort of legacy...\n     * @return {Number}\n     */\n\n  }, {\n    key: \"_count\",\n    get: function get() {\n      return this._allObjects.size + this._factoryCreateOperations.size;\n    }\n    /**\n     * How many more resources does the pool have room for\n     * @return {Number} number of resources the pool could create before hitting any limits\n     */\n\n  }, {\n    key: \"spareResourceCapacity\",\n    get: function get() {\n      return this._config.max - (this._allObjects.size + this._factoryCreateOperations.size);\n    }\n    /**\n     * see _count above\n     * @return {Number} [description]\n     */\n\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this._count;\n    }\n    /**\n     * number of available resources\n     * @return {Number} [description]\n     */\n\n  }, {\n    key: \"available\",\n    get: function get() {\n      return this._availableObjects.length;\n    }\n    /**\n     * number of resources that are currently acquired\n     * @return {Number} [description]\n     */\n\n  }, {\n    key: \"borrowed\",\n    get: function get() {\n      return this._resourceLoans.size;\n    }\n    /**\n     * number of waiting acquire calls\n     * @return {Number} [description]\n     */\n\n  }, {\n    key: \"pending\",\n    get: function get() {\n      return this._waitingClientsQueue.length;\n    }\n    /**\n     * maximum size of the pool\n     * @return {Number} [description]\n     */\n\n  }, {\n    key: \"max\",\n    get: function get() {\n      return this._config.max;\n    }\n    /**\n     * minimum size of the pool\n     * @return {Number} [description]\n     */\n\n  }, {\n    key: \"min\",\n    get: function get() {\n      return this._config.min;\n    }\n  }]);\n\n  return Pool;\n}(EventEmitter);\n\nmodule.exports = Pool;","map":null,"metadata":{},"sourceType":"script"}