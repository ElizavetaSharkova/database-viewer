{"ast":null,"code":"'use strict';\n\nvar _get = require(\"C:\\\\Users\\\\elizaveta.sharkova\\\\Learning\\\\React\\\\First\\\\database-viewer\\\\node_modules\\\\@babel\\\\runtime/helpers/get\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\elizaveta.sharkova\\\\Learning\\\\React\\\\First\\\\database-viewer\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\elizaveta.sharkova\\\\Learning\\\\React\\\\First\\\\database-viewer\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\elizaveta.sharkova\\\\Learning\\\\React\\\\First\\\\database-viewer\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\elizaveta.sharkova\\\\Learning\\\\React\\\\First\\\\database-viewer\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\elizaveta.sharkova\\\\Learning\\\\React\\\\First\\\\database-viewer\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar tds = require('tedious');\n\nvar debug = require('debug')('mssql:tedi');\n\nvar base = require('./base');\n\nvar TYPES = require('./datatypes').TYPES;\n\nvar declare = require('./datatypes').declare;\n\nvar cast = require('./datatypes').cast;\n\nvar DECLARATIONS = require('./datatypes').DECLARATIONS;\n\nvar UDT = require('./udt').PARSERS;\n\nvar Table = require('./table');\n\nvar IDS = require('./utils').IDS;\n\nvar JSON_COLUMN_ID = 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B';\nvar XML_COLUMN_ID = 'XML_F52E2B61-18A1-11d1-B105-00805F49916B';\nvar N_TYPES = {\n  BitN: 0x68,\n  DateTimeN: 0x6F,\n  DecimalN: 0x6A,\n  FloatN: 0x6D,\n  IntN: 0x26,\n  MoneyN: 0x6E,\n  NumericN: 0x6C\n};\n\nvar getTediousType = function getTediousType(type) {\n  switch (type) {\n    case TYPES.VarChar:\n      return tds.TYPES.VarChar;\n\n    case TYPES.NVarChar:\n      return tds.TYPES.NVarChar;\n\n    case TYPES.Text:\n      return tds.TYPES.Text;\n\n    case TYPES.Int:\n      return tds.TYPES.Int;\n\n    case TYPES.BigInt:\n      return tds.TYPES.BigInt;\n\n    case TYPES.TinyInt:\n      return tds.TYPES.TinyInt;\n\n    case TYPES.SmallInt:\n      return tds.TYPES.SmallInt;\n\n    case TYPES.Bit:\n      return tds.TYPES.Bit;\n\n    case TYPES.Float:\n      return tds.TYPES.Float;\n\n    case TYPES.Decimal:\n      return tds.TYPES.Decimal;\n\n    case TYPES.Numeric:\n      return tds.TYPES.Numeric;\n\n    case TYPES.Real:\n      return tds.TYPES.Real;\n\n    case TYPES.Money:\n      return tds.TYPES.Money;\n\n    case TYPES.SmallMoney:\n      return tds.TYPES.SmallMoney;\n\n    case TYPES.Time:\n      return tds.TYPES.Time;\n\n    case TYPES.Date:\n      return tds.TYPES.Date;\n\n    case TYPES.DateTime:\n      return tds.TYPES.DateTime;\n\n    case TYPES.DateTime2:\n      return tds.TYPES.DateTime2;\n\n    case TYPES.DateTimeOffset:\n      return tds.TYPES.DateTimeOffset;\n\n    case TYPES.SmallDateTime:\n      return tds.TYPES.SmallDateTime;\n\n    case TYPES.UniqueIdentifier:\n      return tds.TYPES.UniqueIdentifier;\n\n    case TYPES.Xml:\n      return tds.TYPES.NVarChar;\n\n    case TYPES.Char:\n      return tds.TYPES.Char;\n\n    case TYPES.NChar:\n      return tds.TYPES.NChar;\n\n    case TYPES.NText:\n      return tds.TYPES.NVarChar;\n\n    case TYPES.Image:\n      return tds.TYPES.Image;\n\n    case TYPES.Binary:\n      return tds.TYPES.Binary;\n\n    case TYPES.VarBinary:\n      return tds.TYPES.VarBinary;\n\n    case TYPES.UDT:\n    case TYPES.Geography:\n    case TYPES.Geometry:\n      return tds.TYPES.UDT;\n\n    case TYPES.TVP:\n      return tds.TYPES.TVP;\n\n    case TYPES.Variant:\n      return tds.TYPES.Variant;\n\n    default:\n      return type;\n  }\n};\n\nvar getMssqlType = function getMssqlType(type, length) {\n  if (typeof type !== 'object') return undefined;\n\n  switch (type) {\n    case tds.TYPES.Char:\n      return TYPES.Char;\n\n    case tds.TYPES.NChar:\n      return TYPES.NChar;\n\n    case tds.TYPES.VarChar:\n      return TYPES.VarChar;\n\n    case tds.TYPES.NVarChar:\n      return TYPES.NVarChar;\n\n    case tds.TYPES.Text:\n      return TYPES.Text;\n\n    case tds.TYPES.NText:\n      return TYPES.NText;\n\n    case tds.TYPES.Int:\n      return TYPES.Int;\n\n    case tds.TYPES.BigInt:\n      return TYPES.BigInt;\n\n    case tds.TYPES.TinyInt:\n      return TYPES.TinyInt;\n\n    case tds.TYPES.SmallInt:\n      return TYPES.SmallInt;\n\n    case tds.TYPES.Bit:\n      return TYPES.Bit;\n\n    case tds.TYPES.Float:\n      return TYPES.Float;\n\n    case tds.TYPES.Real:\n      return TYPES.Real;\n\n    case tds.TYPES.Money:\n      return TYPES.Money;\n\n    case tds.TYPES.SmallMoney:\n      return TYPES.SmallMoney;\n\n    case tds.TYPES.Numeric:\n      return TYPES.Numeric;\n\n    case tds.TYPES.Decimal:\n      return TYPES.Decimal;\n\n    case tds.TYPES.DateTime:\n      return TYPES.DateTime;\n\n    case tds.TYPES.Time:\n      return TYPES.Time;\n\n    case tds.TYPES.Date:\n      return TYPES.Date;\n\n    case tds.TYPES.DateTime2:\n      return TYPES.DateTime2;\n\n    case tds.TYPES.DateTimeOffset:\n      return TYPES.DateTimeOffset;\n\n    case tds.TYPES.SmallDateTime:\n      return TYPES.SmallDateTime;\n\n    case tds.TYPES.UniqueIdentifier:\n      return TYPES.UniqueIdentifier;\n\n    case tds.TYPES.Image:\n      return TYPES.Image;\n\n    case tds.TYPES.Binary:\n      return TYPES.Binary;\n\n    case tds.TYPES.VarBinary:\n      return TYPES.VarBinary;\n\n    case tds.TYPES.Xml:\n      return TYPES.Xml;\n\n    case tds.TYPES.UDT:\n      return TYPES.UDT;\n\n    case tds.TYPES.TVP:\n      return TYPES.TVP;\n\n    case tds.TYPES.Variant:\n      return TYPES.Variant;\n\n    default:\n      switch (type.id) {\n        case N_TYPES.BitN:\n          return TYPES.Bit;\n\n        case N_TYPES.NumericN:\n          return TYPES.Numeric;\n\n        case N_TYPES.DecimalN:\n          return TYPES.Decimal;\n\n        case N_TYPES.IntN:\n          if (length === 8) return TYPES.BigInt;\n          if (length === 4) return TYPES.Int;\n          if (length === 2) return TYPES.SmallInt;\n          return TYPES.TinyInt;\n\n        case N_TYPES.FloatN:\n          if (length === 8) return TYPES.Float;\n          return TYPES.Real;\n\n        case N_TYPES.MoneyN:\n          if (length === 8) return TYPES.Money;\n          return TYPES.SmallMoney;\n\n        case N_TYPES.DateTimeN:\n          if (length === 8) return TYPES.DateTime;\n          return TYPES.SmallDateTime;\n      }\n\n  }\n};\n\nvar createColumns = function createColumns(metadata) {\n  var out = {};\n\n  for (var index = 0, length = metadata.length; index < length; index++) {\n    var column = metadata[index];\n    out[column.colName] = {\n      index: index,\n      name: column.colName,\n      length: column.dataLength,\n      type: getMssqlType(column.type, column.dataLength),\n      scale: column.scale,\n      precision: column.precision,\n      nullable: !!(column.flags & 0x01),\n      caseSensitive: !!(column.flags & 0x02),\n      identity: !!(column.flags & 0x10),\n      readOnly: !(column.flags & 0x0C)\n    };\n\n    if (column.udtInfo) {\n      out[column.colName].udt = {\n        name: column.udtInfo.typeName,\n        database: column.udtInfo.dbname,\n        schema: column.udtInfo.owningSchema,\n        assembly: column.udtInfo.assemblyName\n      };\n\n      if (DECLARATIONS[column.udtInfo.typeName]) {\n        out[column.colName].type = DECLARATIONS[column.udtInfo.typeName];\n      }\n    }\n  }\n\n  return out;\n};\n\nvar valueCorrection = function valueCorrection(value, metadata) {\n  if (metadata.type === tds.TYPES.UDT && value != null) {\n    if (UDT[metadata.udtInfo.typeName]) {\n      return UDT[metadata.udtInfo.typeName](value);\n    } else {\n      return value;\n    }\n  } else {\n    return value;\n  }\n};\n\nvar parameterCorrection = function parameterCorrection(value) {\n  if (value instanceof Table) {\n    var tvp = {\n      name: value.name,\n      schema: value.schema,\n      columns: [],\n      rows: value.rows\n    };\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = value.columns[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var col = _step.value;\n        tvp.columns.push({\n          name: col.name,\n          type: getTediousType(col.type),\n          length: col.length,\n          scale: col.scale,\n          precision: col.precision\n        });\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return tvp;\n  } else {\n    return value;\n  }\n};\n\nvar ConnectionPool =\n/*#__PURE__*/\nfunction (_base$ConnectionPool) {\n  _inherits(ConnectionPool, _base$ConnectionPool);\n\n  function ConnectionPool() {\n    _classCallCheck(this, ConnectionPool);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ConnectionPool).apply(this, arguments));\n  }\n\n  _createClass(ConnectionPool, [{\n    key: \"_poolCreate\",\n    value: function _poolCreate() {\n      var _this = this;\n\n      return new base.Promise(function (resolve, reject) {\n        var cfg = {\n          userName: _this.config.user,\n          password: _this.config.password,\n          server: _this.config.server,\n          options: Object.assign({\n            encrypt: typeof _this.config.encrypt === 'boolean' ? _this.config.encrypt : false\n          }, _this.config.options),\n          domain: _this.config.domain\n        };\n        cfg.options.database = _this.config.database;\n        cfg.options.port = _this.config.port;\n        cfg.options.connectTimeout = _this.config.connectionTimeout || _this.config.timeout || 15000;\n        cfg.options.requestTimeout = _this.config.requestTimeout != null ? _this.config.requestTimeout : 15000;\n        cfg.options.tdsVersion = cfg.options.tdsVersion || '7_4';\n        cfg.options.rowCollectionOnDone = false;\n        cfg.options.rowCollectionOnRequestCompletion = false;\n        cfg.options.useColumnNames = false;\n        cfg.options.appName = cfg.options.appName || 'node-mssql'; // tedious always connect via tcp when port is specified\n\n        if (cfg.options.instanceName) delete cfg.options.port;\n        if (isNaN(cfg.options.requestTimeout)) cfg.options.requestTimeout = 15000;\n        if (cfg.options.requestTimeout === Infinity) cfg.options.requestTimeout = 0;\n        if (cfg.options.requestTimeout < 0) cfg.options.requestTimeout = 0;\n\n        if (_this.config.debug) {\n          cfg.options.debug = {\n            packet: true,\n            token: true,\n            data: true,\n            payload: true\n          };\n        }\n\n        var tedious = new tds.Connection(cfg);\n        IDS.add(tedious, 'Connection');\n        debug('pool(%d): connection #%d created', IDS.get(_this), IDS.get(tedious));\n        debug('connection(%d): establishing', IDS.get(tedious));\n        tedious.once('connect', function (err) {\n          if (err) {\n            err = new base.ConnectionError(err);\n            return reject(err);\n          }\n\n          debug('connection(%d): established', IDS.get(tedious));\n          resolve(tedious);\n        });\n        tedious.on('error', function (err) {\n          if (err.code === 'ESOCKET') {\n            tedious.hasError = true;\n            reject(err);\n            return;\n          }\n\n          _this.emit('error', err);\n\n          reject(err);\n        });\n\n        if (_this.config.debug) {\n          tedious.on('debug', _this.emit.bind(_this, 'debug', tedious));\n        }\n\n        if (typeof _this.config.beforeConnect === 'function') {\n          _this.config.beforeConnect(tedious);\n        }\n      });\n    }\n  }, {\n    key: \"_poolValidate\",\n    value: function _poolValidate(tedious) {\n      return new base.Promise(function (resolve, reject) {\n        resolve(!tedious.closed && !tedious.hasError);\n      });\n    }\n  }, {\n    key: \"_poolDestroy\",\n    value: function _poolDestroy(tedious) {\n      return new base.Promise(function (resolve, reject) {\n        debug('connection(%d): destroying', IDS.get(tedious));\n        tedious.once('end', function () {\n          debug('connection(%d): destroyed', IDS.get(tedious));\n          resolve();\n        });\n        tedious.close();\n      });\n    }\n  }]);\n\n  return ConnectionPool;\n}(base.ConnectionPool);\n\nvar Transaction =\n/*#__PURE__*/\nfunction (_base$Transaction) {\n  _inherits(Transaction, _base$Transaction);\n\n  function Transaction(parent) {\n    var _this2;\n\n    _classCallCheck(this, Transaction);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Transaction).call(this, parent));\n\n    _this2._abort = function () {\n      if (!_this2._rollbackRequested) {\n        // transaction interrupted because of XACT_ABORT\n        var pc = _this2._acquiredConnection; // defer releasing so connection can switch from SentClientRequest to LoggedIn state\n\n        setImmediate(_this2.parent.release.bind(_this2.parent), pc);\n\n        _this2._acquiredConnection.removeListener('rollbackTransaction', _this2._abort);\n\n        _this2._acquiredConnection = null;\n        _this2._acquiredConfig = null;\n        _this2._aborted = true;\n\n        _this2.emit('rollback', true);\n      }\n    };\n\n    return _this2;\n  }\n\n  _createClass(Transaction, [{\n    key: \"_begin\",\n    value: function _begin(isolationLevel, callback) {\n      var _this3 = this;\n\n      _get(_getPrototypeOf(Transaction.prototype), \"_begin\", this).call(this, isolationLevel, function (err) {\n        if (err) return callback(err);\n        debug('transaction(%d): begin', IDS.get(_this3));\n\n        _this3.parent.acquire(_this3, function (err, connection, config) {\n          if (err) return callback(err);\n          _this3._acquiredConnection = connection;\n\n          _this3._acquiredConnection.on('rollbackTransaction', _this3._abort);\n\n          _this3._acquiredConfig = config;\n          connection.beginTransaction(function (err) {\n            if (err) err = new base.TransactionError(err);\n            debug('transaction(%d): begun', IDS.get(_this3));\n            callback(err);\n          }, _this3.name, _this3.isolationLevel);\n        });\n      });\n    }\n  }, {\n    key: \"_commit\",\n    value: function _commit(callback) {\n      var _this4 = this;\n\n      _get(_getPrototypeOf(Transaction.prototype), \"_commit\", this).call(this, function (err) {\n        if (err) return callback(err);\n        debug('transaction(%d): commit', IDS.get(_this4));\n\n        _this4._acquiredConnection.commitTransaction(function (err) {\n          if (err) err = new base.TransactionError(err);\n\n          _this4._acquiredConnection.removeListener('rollbackTransaction', _this4._abort);\n\n          _this4.parent.release(_this4._acquiredConnection);\n\n          _this4._acquiredConnection = null;\n          _this4._acquiredConfig = null;\n          if (!err) debug('transaction(%d): commited', IDS.get(_this4));\n          callback(err);\n        });\n      });\n    }\n  }, {\n    key: \"_rollback\",\n    value: function _rollback(callback) {\n      var _this5 = this;\n\n      _get(_getPrototypeOf(Transaction.prototype), \"_rollback\", this).call(this, function (err) {\n        if (err) return callback(err);\n        debug('transaction(%d): rollback', IDS.get(_this5));\n\n        _this5._acquiredConnection.rollbackTransaction(function (err) {\n          if (err) err = new base.TransactionError(err);\n\n          _this5._acquiredConnection.removeListener('rollbackTransaction', _this5._abort);\n\n          _this5.parent.release(_this5._acquiredConnection);\n\n          _this5._acquiredConnection = null;\n          _this5._acquiredConfig = null;\n          if (!err) debug('transaction(%d): rolled back', IDS.get(_this5));\n          callback(err);\n        });\n      });\n    }\n  }]);\n\n  return Transaction;\n}(base.Transaction);\n\nvar Request =\n/*#__PURE__*/\nfunction (_base$Request) {\n  _inherits(Request, _base$Request);\n\n  function Request() {\n    _classCallCheck(this, Request);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Request).apply(this, arguments));\n  }\n\n  _createClass(Request, [{\n    key: \"_batch\",\n\n    /*\n    Execute specified sql batch.\n    */\n    value: function _batch(batch, callback) {\n      this._isBatch = true;\n\n      this._query(batch, callback);\n    }\n    /*\n    Bulk load.\n    */\n\n  }, {\n    key: \"_bulk\",\n    value: function _bulk(table, callback) {\n      var _this6 = this;\n\n      _get(_getPrototypeOf(Request.prototype), \"_bulk\", this).call(this, table, function (err) {\n        if (err) return callback(err);\n\n        table._makeBulk();\n\n        if (!table.name) {\n          return callback(new base.RequestError('Table name must be specified for bulk insert.', 'ENAME'));\n        }\n\n        if (table.name.charAt(0) === '@') {\n          return callback(new base.RequestError(\"You can't use table variables for bulk insert.\", 'ENAME'));\n        }\n\n        var errors = [];\n        var errorHandlers = {};\n        var hasReturned = false;\n\n        var handleError = function handleError(doReturn, connection, info) {\n          var err = new Error(info.message);\n          err.info = info;\n          err = new base.RequestError(err, 'EREQUEST');\n\n          if (_this6.stream) {\n            _this6.emit('error', err);\n          } else {\n            if (doReturn && !hasReturned) {\n              if (connection) {\n                for (var event in errorHandlers) {\n                  connection.removeListener(event, errorHandlers[event]);\n                }\n\n                _this6.parent.release(connection);\n              }\n\n              hasReturned = true;\n              callback(err);\n            }\n          } // we must collect errors even in stream mode\n\n\n          errors.push(err);\n        };\n\n        var handleInfo = function handleInfo(msg) {\n          _this6.emit('info', {\n            message: msg.message,\n            number: msg.number,\n            state: msg.state,\n            class: msg.class,\n            lineNumber: msg.lineNumber,\n            serverName: msg.serverName,\n            procName: msg.procName\n          });\n        };\n\n        _this6.parent.acquire(_this6, function (err, connection) {\n          if (err) return callback(err);\n          debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(_this6));\n\n          if (_this6.canceled) {\n            debug('request(%d): canceled', IDS.get(_this6));\n\n            _this6.parent.release(connection);\n\n            return callback(new base.RequestError('Canceled.', 'ECANCEL'));\n          }\n\n          _this6._cancel = function () {\n            debug('request(%d): cancel', IDS.get(_this6));\n            connection.cancel();\n          }; // attach handler to handle multiple error messages\n\n\n          connection.on('infoMessage', errorHandlers.infoMessage = handleInfo);\n          connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection));\n          connection.on('error', errorHandlers.error = handleError.bind(null, true, connection));\n\n          var done = function done(err, rowCount) {\n            // to make sure we handle no-sql errors as well\n            if (err && (!errors.length || errors.length && err.message !== errors[errors.length - 1].message)) {\n              err = new base.RequestError(err, 'EREQUEST');\n              if (_this6.stream) _this6.emit('error', err);\n              errors.push(err);\n            }\n\n            delete _this6._cancel;\n            var error;\n\n            if (errors.length && !_this6.stream) {\n              error = errors.pop();\n              error.precedingErrors = errors;\n            }\n\n            if (!hasReturned) {\n              for (var event in errorHandlers) {\n                connection.removeListener(event, errorHandlers[event]);\n              }\n\n              _this6.parent.release(connection);\n\n              hasReturned = true;\n\n              if (_this6.stream) {\n                callback(null, rowCount);\n              } else {\n                callback(error, rowCount);\n              }\n            }\n          };\n\n          var bulk = connection.newBulkLoad(table.path, done);\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n          var _iteratorError2 = undefined;\n\n          try {\n            for (var _iterator2 = table.columns[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              var col = _step2.value;\n              bulk.addColumn(col.name, getTediousType(col.type), {\n                nullable: col.nullable,\n                length: col.length,\n                scale: col.scale,\n                precision: col.precision\n              });\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                _iterator2.return();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n\n          var _iteratorNormalCompletion3 = true;\n          var _didIteratorError3 = false;\n          var _iteratorError3 = undefined;\n\n          try {\n            for (var _iterator3 = table.rows[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n              var row = _step3.value;\n              bulk.addRow(row);\n            }\n          } catch (err) {\n            _didIteratorError3 = true;\n            _iteratorError3 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n                _iterator3.return();\n              }\n            } finally {\n              if (_didIteratorError3) {\n                throw _iteratorError3;\n              }\n            }\n          }\n\n          if (table.create) {\n            var objectid = table.temporary ? \"tempdb..[\".concat(table.name, \"]\") : table.path;\n            var req = new tds.Request(\"if object_id('\".concat(objectid.replace(/'/g, '\\'\\''), \"') is null \").concat(table.declare()), function (err) {\n              if (err) return done(err);\n              connection.execBulkLoad(bulk);\n            });\n            connection.execSqlBatch(req);\n          } else {\n            connection.execBulkLoad(bulk);\n          }\n        });\n      });\n    }\n    /*\n    Execute specified sql command.\n    */\n\n  }, {\n    key: \"_query\",\n    value: function _query(command, callback) {\n      var _this7 = this;\n\n      _get(_getPrototypeOf(Request.prototype), \"_query\", this).call(this, command, function (err) {\n        if (err) return callback(err);\n        var recordsets = [];\n        var errors = [];\n        var errorHandlers = {};\n        var output = {};\n        var rowsAffected = [];\n        var columns = {};\n        var recordset = [];\n        var batchLastRow = null;\n        var batchHasOutput = false;\n        var isChunkedRecordset = false;\n        var chunksBuffer = null;\n        var hasReturned = false;\n\n        var handleError = function handleError(doReturn, connection, info) {\n          var err = new Error(info.message);\n          err.info = info;\n          err = new base.RequestError(err, 'EREQUEST');\n\n          if (_this7.stream) {\n            _this7.emit('error', err);\n          } else {\n            if (doReturn && !hasReturned) {\n              if (connection) {\n                for (var event in errorHandlers) {\n                  connection.removeListener(event, errorHandlers[event]);\n                }\n\n                _this7.parent.release(connection);\n              }\n\n              hasReturned = true;\n              callback(err);\n            }\n          } // we must collect errors even in stream mode\n\n\n          errors.push(err);\n        };\n\n        var handleInfo = function handleInfo(msg) {\n          _this7.emit('info', {\n            message: msg.message,\n            number: msg.number,\n            state: msg.state,\n            class: msg.class,\n            lineNumber: msg.lineNumber,\n            serverName: msg.serverName,\n            procName: msg.procName\n          });\n        };\n\n        _this7.parent.acquire(_this7, function (err, connection, config) {\n          if (err) return callback(err);\n          debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(_this7));\n          var row;\n\n          if (_this7.canceled) {\n            debug('request(%d): canceled', IDS.get(_this7));\n\n            _this7.parent.release(connection);\n\n            return callback(new base.RequestError('Canceled.', 'ECANCEL'));\n          }\n\n          _this7._cancel = function () {\n            debug('request(%d): cancel', IDS.get(_this7));\n            connection.cancel();\n          }; // attach handler to handle multiple error messages\n\n\n          connection.on('infoMessage', errorHandlers.infoMessage = handleInfo);\n          connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection));\n          connection.on('error', errorHandlers.error = handleError.bind(null, true, connection));\n          debug('request(%d): query', IDS.get(_this7), command);\n          var req = new tds.Request(command, function (err) {\n            // to make sure we handle no-sql errors as well\n            if (err && (!errors.length || errors.length && err.message !== errors[errors.length - 1].message)) {\n              err = new base.RequestError(err, 'EREQUEST');\n              if (_this7.stream) _this7.emit('error', err);\n              errors.push(err);\n            } // process batch outputs\n\n\n            if (batchHasOutput) {\n              if (!_this7.stream) batchLastRow = recordsets.pop()[0];\n\n              for (var name in batchLastRow) {\n                var value = batchLastRow[name];\n\n                if (name !== '___return___') {\n                  output[name] = value === tds.TYPES.Null ? null : value;\n                }\n              }\n            }\n\n            delete _this7._cancel;\n            var error;\n\n            if (errors.length && !_this7.stream) {\n              error = errors.pop();\n              error.precedingErrors = errors;\n            }\n\n            if (!hasReturned) {\n              for (var event in errorHandlers) {\n                connection.removeListener(event, errorHandlers[event]);\n              }\n\n              _this7.parent.release(connection);\n\n              hasReturned = true;\n\n              if (error) {\n                debug('request(%d): failed', IDS.get(_this7), error);\n              } else {\n                debug('request(%d): completed', IDS.get(_this7));\n              }\n\n              if (_this7.stream) {\n                callback(null, null, output, rowsAffected);\n              } else {\n                callback(error, recordsets, output, rowsAffected);\n              }\n            }\n          });\n          req.on('columnMetadata', function (metadata) {\n            columns = createColumns(metadata);\n            isChunkedRecordset = false;\n\n            if (metadata.length === 1 && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {\n              isChunkedRecordset = true;\n              chunksBuffer = [];\n            }\n\n            if (_this7.stream) {\n              if (_this7._isBatch) {\n                // don't stream recordset with output values in batches\n                if (!columns.___return___) {\n                  _this7.emit('recordset', columns);\n                }\n              } else {\n                _this7.emit('recordset', columns);\n              }\n            }\n          });\n\n          var doneHandler = function doneHandler(rowCount, more) {\n            if (rowCount != null) rowsAffected.push(rowCount); // this function is called even when select only set variables so we should skip adding a new recordset\n\n            if (Object.keys(columns).length === 0) return;\n\n            if (isChunkedRecordset) {\n              var concatenatedChunks = chunksBuffer.join('');\n\n              if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {\n                try {\n                  if (concatenatedChunks === '') {\n                    row = null;\n                  } else {\n                    row = JSON.parse(concatenatedChunks);\n                  }\n                } catch (ex) {\n                  row = null;\n                  var ex2 = new base.RequestError(new Error(\"Failed to parse incoming JSON. \".concat(ex.message)), 'EJSON');\n                  if (_this7.stream) _this7.emit('error', ex2); // we must collect errors even in stream mode\n\n                  errors.push(ex2);\n                }\n              } else {\n                row = {};\n                row[Object.keys(columns)[0]] = concatenatedChunks;\n              }\n\n              chunksBuffer = null;\n\n              if (_this7.stream) {\n                _this7.emit('row', row);\n              } else {\n                recordset.push(row);\n              }\n            }\n\n            if (!_this7.stream) {\n              // all rows of current recordset loaded\n              Object.defineProperty(recordset, 'columns', {\n                enumerable: false,\n                configurable: true,\n                value: columns\n              });\n              Object.defineProperty(recordset, 'toTable', {\n                enumerable: false,\n                configurable: true,\n                value: function value(name) {\n                  return Table.fromRecordset(this, name);\n                }\n              });\n              recordsets.push(recordset);\n            }\n\n            recordset = [];\n            columns = {};\n          };\n\n          req.on('doneInProc', doneHandler); // doneInProc handlers are used in both queries and batches\n\n          req.on('done', doneHandler); // done handlers are used in batches\n\n          req.on('returnValue', function (parameterName, value, metadata) {\n            output[parameterName] = value === tds.TYPES.Null ? null : value;\n          });\n          req.on('row', function (columns) {\n            if (!recordset) recordset = [];\n\n            if (isChunkedRecordset) {\n              return chunksBuffer.push(columns[0].value);\n            }\n\n            row = {};\n            var _iteratorNormalCompletion4 = true;\n            var _didIteratorError4 = false;\n            var _iteratorError4 = undefined;\n\n            try {\n              for (var _iterator4 = columns[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                var col = _step4.value;\n                col.value = valueCorrection(col.value, col.metadata);\n                var exi = row[col.metadata.colName];\n\n                if (exi != null) {\n                  if (exi instanceof Array) {\n                    exi.push(col.value);\n                  } else {\n                    row[col.metadata.colName] = [exi, col.value];\n                  }\n                } else {\n                  row[col.metadata.colName] = col.value;\n                }\n              }\n            } catch (err) {\n              _didIteratorError4 = true;\n              _iteratorError4 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n                  _iterator4.return();\n                }\n              } finally {\n                if (_didIteratorError4) {\n                  throw _iteratorError4;\n                }\n              }\n            }\n\n            if (_this7.stream) {\n              if (_this7._isBatch) {\n                // dont stream recordset with output values in batches\n                if (row.___return___) {\n                  batchLastRow = row;\n                } else {\n                  _this7.emit('row', row);\n                }\n              } else {\n                _this7.emit('row', row);\n              }\n            } else {\n              recordset.push(row);\n            }\n          });\n\n          if (_this7._isBatch) {\n            if (Object.keys(_this7.parameters).length) {\n              for (var name in _this7.parameters) {\n                var param = _this7.parameters[name];\n                var value = getTediousType(param.type).validate(param.value);\n\n                if (value instanceof TypeError) {\n                  value = new base.RequestError(\"Validation failed for parameter '\".concat(name, \"'. \").concat(value.message), 'EPARAM');\n\n                  _this7.parent.release(connection);\n\n                  return callback(value);\n                }\n\n                param.value = value;\n              }\n\n              var declarations = [];\n\n              for (var _name in _this7.parameters) {\n                var _param = _this7.parameters[_name];\n                declarations.push(\"@\".concat(_name, \" \").concat(declare(_param.type, _param)));\n              }\n\n              var assigns = [];\n\n              for (var _name2 in _this7.parameters) {\n                var _param2 = _this7.parameters[_name2];\n                assigns.push(\"@\".concat(_name2, \" = \").concat(cast(_param2.value, _param2.type, _param2)));\n              }\n\n              var selects = [];\n\n              for (var _name3 in _this7.parameters) {\n                var _param3 = _this7.parameters[_name3];\n\n                if (_param3.io === 2) {\n                  selects.push(\"@\".concat(_name3, \" as [\").concat(_name3, \"]\"));\n                }\n              }\n\n              batchHasOutput = selects.length > 0;\n              req.sqlTextOrProcedure = \"declare \".concat(declarations.join(', '), \";select \").concat(assigns.join(', '), \";\").concat(req.sqlTextOrProcedure, \";\").concat(batchHasOutput ? \"select 1 as [___return___], \".concat(selects.join(', ')) : '');\n            }\n          } else {\n            for (var _name4 in _this7.parameters) {\n              var _param4 = _this7.parameters[_name4];\n\n              if (_param4.io === 1) {\n                req.addParameter(_param4.name, getTediousType(_param4.type), parameterCorrection(_param4.value), {\n                  length: _param4.length,\n                  scale: _param4.scale,\n                  precision: _param4.precision\n                });\n              } else {\n                req.addOutputParameter(_param4.name, getTediousType(_param4.type), parameterCorrection(_param4.value), {\n                  length: _param4.length,\n                  scale: _param4.scale,\n                  precision: _param4.precision\n                });\n              }\n            }\n          }\n\n          connection[_this7._isBatch ? 'execSqlBatch' : 'execSql'](req);\n        });\n      });\n    }\n    /*\n    Execute stored procedure with specified parameters.\n    */\n\n  }, {\n    key: \"_execute\",\n    value: function _execute(procedure, callback) {\n      var _this8 = this;\n\n      _get(_getPrototypeOf(Request.prototype), \"_execute\", this).call(this, procedure, function (err) {\n        if (err) return callback(err);\n        var recordsets = [];\n        var errors = [];\n        var errorHandlers = {};\n        var output = {};\n        var rowsAffected = [];\n        var columns = {};\n        var recordset = [];\n        var returnValue = 0;\n        var isChunkedRecordset = false;\n        var chunksBuffer = null;\n        var hasReturned = false;\n\n        var handleError = function handleError(doReturn, connection, info) {\n          var err = new Error(info.message);\n          err.info = info;\n          err = new base.RequestError(err, 'EREQUEST');\n\n          if (_this8.stream) {\n            _this8.emit('error', err);\n          } else {\n            if (doReturn && !hasReturned) {\n              if (connection) {\n                for (var event in errorHandlers) {\n                  connection.removeListener(event, errorHandlers[event]);\n                }\n\n                _this8.parent.release(connection);\n              }\n\n              hasReturned = true;\n              callback(err);\n            }\n          } // we must collect errors even in stream mode\n\n\n          errors.push(err);\n        };\n\n        var handleInfo = function handleInfo(msg) {\n          _this8.emit('info', {\n            message: msg.message,\n            number: msg.number,\n            state: msg.state,\n            class: msg.class,\n            lineNumber: msg.lineNumber,\n            serverName: msg.serverName,\n            procName: msg.procName\n          });\n        };\n\n        _this8.parent.acquire(_this8, function (err, connection, config) {\n          if (err) return callback(err);\n          debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(_this8));\n          var row;\n\n          if (_this8.canceled) {\n            debug('request(%d): canceled', IDS.get(_this8));\n\n            _this8.parent.release(connection);\n\n            return callback(new base.RequestError('Canceled.', 'ECANCEL'));\n          }\n\n          _this8._cancel = function () {\n            debug('request(%d): cancel', IDS.get(_this8));\n            connection.cancel();\n          }; // attach handler to handle multiple error messages\n\n\n          connection.on('infoMessage', errorHandlers.infoMessage = handleInfo);\n          connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection));\n          connection.on('error', errorHandlers.error = handleError.bind(null, true, connection));\n          debug('request(%d): execute', IDS.get(_this8), procedure);\n          var req = new tds.Request(procedure, function (err) {\n            // to make sure we handle no-sql errors as well\n            if (err && (!errors.length || errors.length && err.message !== errors[errors.length - 1].message)) {\n              err = new base.RequestError(err, 'EREQUEST');\n              if (_this8.stream) _this8.emit('error', err);\n              errors.push(err);\n            }\n\n            delete _this8._cancel;\n            var error;\n\n            if (errors.length && !_this8.stream) {\n              error = errors.pop();\n              error.precedingErrors = errors;\n            }\n\n            if (!hasReturned) {\n              for (var event in errorHandlers) {\n                connection.removeListener(event, errorHandlers[event]);\n              }\n\n              _this8.parent.release(connection);\n\n              hasReturned = true;\n\n              if (error) {\n                debug('request(%d): failed', IDS.get(_this8), error);\n              } else {\n                debug('request(%d): complete', IDS.get(_this8));\n              }\n\n              if (_this8.stream) {\n                callback(null, null, output, returnValue, rowsAffected);\n              } else {\n                callback(error, recordsets, output, returnValue, rowsAffected);\n              }\n            }\n          });\n          req.on('columnMetadata', function (metadata) {\n            columns = createColumns(metadata);\n            isChunkedRecordset = false;\n\n            if (metadata.length === 1 && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {\n              isChunkedRecordset = true;\n              chunksBuffer = [];\n            }\n\n            if (_this8.stream) _this8.emit('recordset', columns);\n          });\n          req.on('row', function (columns) {\n            if (!recordset) recordset = [];\n\n            if (isChunkedRecordset) {\n              return chunksBuffer.push(columns[0].value);\n            }\n\n            row = {};\n            var _iteratorNormalCompletion5 = true;\n            var _didIteratorError5 = false;\n            var _iteratorError5 = undefined;\n\n            try {\n              for (var _iterator5 = columns[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                var col = _step5.value;\n                col.value = valueCorrection(col.value, col.metadata);\n                var exi = row[col.metadata.colName];\n\n                if (exi != null) {\n                  if (exi instanceof Array) {\n                    exi.push(col.value);\n                  } else {\n                    row[col.metadata.colName] = [exi, col.value];\n                  }\n                } else {\n                  row[col.metadata.colName] = col.value;\n                }\n              }\n            } catch (err) {\n              _didIteratorError5 = true;\n              _iteratorError5 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n                  _iterator5.return();\n                }\n              } finally {\n                if (_didIteratorError5) {\n                  throw _iteratorError5;\n                }\n              }\n            }\n\n            if (_this8.stream) {\n              _this8.emit('row', row);\n            } else {\n              recordset.push(row);\n            }\n          });\n          req.on('doneInProc', function (rowCount, more) {\n            if (rowCount != null) rowsAffected.push(rowCount); // filter empty recordsets when NOCOUNT is OFF\n\n            if (Object.keys(columns).length === 0) return;\n\n            if (isChunkedRecordset) {\n              if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {\n                try {\n                  if (chunksBuffer.length === 0) {\n                    row = null;\n                  } else {\n                    row = JSON.parse(chunksBuffer.join(''));\n                  }\n                } catch (ex) {\n                  row = null;\n                  var ex2 = new base.RequestError(new Error(\"Failed to parse incoming JSON. \".concat(ex.message)), 'EJSON');\n                  if (_this8.stream) _this8.emit('error', ex2); // we must collect errors even in stream mode\n\n                  errors.push(ex2);\n                }\n              } else {\n                row = {};\n                row[Object.keys(columns)[0]] = chunksBuffer.join('');\n              }\n\n              chunksBuffer = null;\n\n              if (_this8.stream) {\n                _this8.emit('row', row);\n              } else {\n                recordset.push(row);\n              }\n            }\n\n            if (!_this8.stream) {\n              // all rows of current recordset loaded\n              Object.defineProperty(recordset, 'columns', {\n                enumerable: false,\n                configurable: true,\n                value: columns\n              });\n              Object.defineProperty(recordset, 'toTable', {\n                enumerable: false,\n                configurable: true,\n                value: function value(name) {\n                  return Table.fromRecordset(this, name);\n                }\n              });\n              recordsets.push(recordset);\n            }\n\n            recordset = [];\n            columns = {};\n          });\n          req.on('doneProc', function (rowCount, more, returnStatus) {\n            returnValue = returnStatus;\n          });\n          req.on('returnValue', function (parameterName, value, metadata) {\n            output[parameterName] = value === tds.TYPES.Null ? null : value;\n          });\n\n          for (var name in _this8.parameters) {\n            var param = _this8.parameters[name];\n\n            if (param.io === 1) {\n              req.addParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), {\n                length: param.length,\n                scale: param.scale,\n                precision: param.precision\n              });\n            } else {\n              req.addOutputParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), {\n                length: param.length,\n                scale: param.scale,\n                precision: param.precision\n              });\n            }\n          }\n\n          connection.callProcedure(req);\n        });\n      });\n    }\n  }]);\n\n  return Request;\n}(base.Request);\n\nmodule.exports = Object.assign({\n  ConnectionPool: ConnectionPool,\n  Transaction: Transaction,\n  Request: Request,\n  PreparedStatement: base.PreparedStatement\n}, base.exports);\nObject.defineProperty(module.exports, 'Promise', {\n  enumerable: true,\n  get: function get() {\n    return base.Promise;\n  },\n  set: function set(value) {\n    base.Promise = value;\n  }\n});\nbase.driver.name = 'tedious';\nbase.driver.ConnectionPool = ConnectionPool;\nbase.driver.Transaction = Transaction;\nbase.driver.Request = Request;","map":null,"metadata":{},"sourceType":"script"}