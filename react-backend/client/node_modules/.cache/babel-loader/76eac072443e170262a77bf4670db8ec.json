{"ast":null,"code":"\"use strict\";\n/**\n * Creates an interator for a DoublyLinkedList starting at the given node\n * It's internal cursor will remains relative to the last \"iterated\" node as that\n * node moves through the list until it either iterates to the end of the list,\n * or the the node it's tracking is removed from the list. Until the first 'next'\n * call it tracks the head/tail of the linked list. This means that one can create\n * an iterator on an empty list, then add nodes, and then the iterator will follow\n * those nodes. Because the DoublyLinkedList nodes don't track their owning \"list\" and\n * it's highly inefficient to walk the list for every iteration, the iterator won't know\n * if the node has been detached from one List and added to another list, or if the iterator\n *\n * The created object is an es6 compatible iterator\n */\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\elizaveta.sharkova\\\\Learning\\\\React\\\\First\\\\database-viewer\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\elizaveta.sharkova\\\\Learning\\\\React\\\\First\\\\database-viewer\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar DoublyLinkedListIterator =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param  {Object} doublyLinkedList     a node that is part of a doublyLinkedList\n   * @param  {Boolean} [reverse=false]     is this a reverse iterator? default: false\n   */\n  function DoublyLinkedListIterator(doublyLinkedList, reverse) {\n    _classCallCheck(this, DoublyLinkedListIterator);\n\n    this._list = doublyLinkedList; // NOTE: these key names are tied to the DoublyLinkedListIterator\n\n    this._direction = reverse === true ? \"prev\" : \"next\";\n    this._startPosition = reverse === true ? \"tail\" : \"head\";\n    this._started = false;\n    this._cursor = null;\n    this._done = false;\n  }\n\n  _createClass(DoublyLinkedListIterator, [{\n    key: \"_start\",\n    value: function _start() {\n      this._cursor = this._list[this._startPosition];\n      this._started = true;\n    }\n  }, {\n    key: \"_advanceCursor\",\n    value: function _advanceCursor() {\n      if (this._started === false) {\n        this._started = true;\n        this._cursor = this._list[this._startPosition];\n        return;\n      }\n\n      this._cursor = this._cursor[this._direction];\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._done = false;\n      this._started = false;\n      this._cursor = null;\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      if (this._started === false || this._done === true || this._isCursorDetached()) {\n        return false;\n      }\n\n      this._list.remove(this._cursor);\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      if (this._done === true) {\n        return {\n          done: true\n        };\n      }\n\n      this._advanceCursor(); // if there is no node at the cursor or the node at the cursor is no longer part of\n      // a doubly linked list then we are done/finished/kaput\n\n\n      if (this._cursor === null || this._isCursorDetached()) {\n        this._done = true;\n        return {\n          done: true\n        };\n      }\n\n      return {\n        value: this._cursor,\n        done: false\n      };\n    }\n    /**\n     * Is the node detached from a list?\n     * NOTE: you can trick/bypass/confuse this check by removing a node from one DoublyLinkedList\n     * and adding it to another.\n     * TODO: We can make this smarter by checking the direction of travel and only checking\n     * the required next/prev/head/tail rather than all of them\n     * @return {Boolean}      [description]\n     */\n\n  }, {\n    key: \"_isCursorDetached\",\n    value: function _isCursorDetached() {\n      return this._cursor.prev === null && this._cursor.next === null && this._list.tail !== this._cursor && this._list.head !== this._cursor;\n    }\n  }]);\n\n  return DoublyLinkedListIterator;\n}();\n\nmodule.exports = DoublyLinkedListIterator;","map":null,"metadata":{},"sourceType":"script"}