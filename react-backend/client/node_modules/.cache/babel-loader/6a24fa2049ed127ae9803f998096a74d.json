{"ast":null,"code":"'use strict';\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar dgram = require('dgram');\n\nvar dns = require('dns');\n\nvar net = require('net');\n\nvar punycode = require('punycode');\n\nvar Sender = function () {\n  function Sender(host, port, request) {\n    (0, _classCallCheck3.default)(this, Sender);\n    this.host = host;\n    this.port = port;\n    this.request = request;\n    this.parallelSendStrategy = null;\n  }\n\n  (0, _createClass3.default)(Sender, [{\n    key: 'execute',\n    value: function execute(cb) {\n      if (net.isIP(this.host)) {\n        this.executeForIP(cb);\n      } else {\n        this.executeForHostname(cb);\n      }\n    }\n  }, {\n    key: 'executeForIP',\n    value: function executeForIP(cb) {\n      this.executeForAddresses([{\n        address: this.host\n      }], cb);\n    } // Wrapper for stubbing. Sinon does not have support for stubbing module functions.\n\n  }, {\n    key: 'invokeLookupAll',\n    value: function invokeLookupAll(host, cb) {\n      dns.lookup(punycode.toASCII(host), {\n        all: true\n      }, cb);\n    }\n  }, {\n    key: 'executeForHostname',\n    value: function executeForHostname(cb) {\n      var _this = this;\n\n      this.invokeLookupAll(this.host, function (err, addresses) {\n        if (err) {\n          return cb(err);\n        }\n\n        _this.executeForAddresses(addresses, cb);\n      });\n    } // Wrapper for stubbing creation of Strategy object. Sinon support for constructors\n    // seems limited.\n\n  }, {\n    key: 'createParallelSendStrategy',\n    value: function createParallelSendStrategy(addresses, port, request) {\n      return new ParallelSendStrategy(addresses, port, request);\n    }\n  }, {\n    key: 'executeForAddresses',\n    value: function executeForAddresses(addresses, cb) {\n      this.parallelSendStrategy = this.createParallelSendStrategy(addresses, this.port, this.request);\n      this.parallelSendStrategy.send(cb);\n    }\n  }, {\n    key: 'cancel',\n    value: function cancel() {\n      if (this.parallelSendStrategy) {\n        this.parallelSendStrategy.cancel();\n      }\n    }\n  }]);\n  return Sender;\n}();\n\nvar ParallelSendStrategy = function () {\n  function ParallelSendStrategy(addresses, port, request) {\n    (0, _classCallCheck3.default)(this, ParallelSendStrategy);\n    this.addresses = addresses;\n    this.port = port;\n    this.request = request;\n    this.socketV4 = null;\n    this.socketV6 = null;\n    this.onError = null;\n    this.onMessage = null;\n  }\n\n  (0, _createClass3.default)(ParallelSendStrategy, [{\n    key: 'clearSockets',\n    value: function clearSockets() {\n      var clearSocket = function clearSocket(socket, onError, onMessage) {\n        socket.removeListener('error', onError);\n        socket.removeListener('message', onMessage);\n        socket.close();\n      };\n\n      if (this.socketV4) {\n        clearSocket(this.socketV4, this.onError, this.onMessage);\n        this.socketV4 = null;\n      }\n\n      if (this.socketV6) {\n        clearSocket(this.socketV6, this.onError, this.onMessage);\n        this.socketV6 = null;\n      }\n    }\n  }, {\n    key: 'send',\n    value: function send(cb) {\n      var _this2 = this;\n\n      var errorCount = 0;\n\n      var onError = function onError(err) {\n        errorCount++;\n\n        if (errorCount === _this2.addresses.length) {\n          _this2.clearSockets();\n\n          cb(err);\n        }\n      };\n\n      var onMessage = function onMessage(message) {\n        _this2.clearSockets();\n\n        cb(null, message);\n      };\n\n      var createDgramSocket = function createDgramSocket(udpType, onError, onMessage) {\n        var socket = dgram.createSocket(udpType);\n        socket.on('error', onError);\n        socket.on('message', onMessage);\n        return socket;\n      };\n\n      for (var j = 0; j < this.addresses.length; j++) {\n        var udpTypeV4 = 'udp4';\n        var udpTypeV6 = 'udp6';\n        var udpType = net.isIPv4(this.addresses[j].address) ? udpTypeV4 : udpTypeV6;\n        var socket = void 0;\n\n        if (udpType === udpTypeV4) {\n          if (!this.socketV4) {\n            this.socketV4 = createDgramSocket(udpTypeV4, onError, onMessage);\n          }\n\n          socket = this.socketV4;\n        } else {\n          if (!this.socketV6) {\n            this.socketV6 = createDgramSocket(udpTypeV6, onError, onMessage);\n          }\n\n          socket = this.socketV6;\n        }\n\n        socket.send(this.request, 0, this.request.length, this.port, this.addresses[j].address);\n      }\n\n      this.onError = onError;\n      this.onMessage = onMessage;\n    }\n  }, {\n    key: 'cancel',\n    value: function cancel() {\n      this.clearSockets();\n    }\n  }]);\n  return ParallelSendStrategy;\n}();\n\nmodule.exports.Sender = Sender;\nmodule.exports.ParallelSendStrategy = ParallelSendStrategy;","map":null,"metadata":{},"sourceType":"script"}