{"ast":null,"code":"'use strict';\n\nvar _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/* globals $Values */\n\n\nvar tls = require('tls');\n\nvar crypto = require('crypto');\n\nvar DuplexPair = require('native-duplexpair');\n\nvar _require = require('events'),\n    EventEmitter = _require.EventEmitter;\n\nvar _require2 = require('./packet'),\n    TYPE = _require2.TYPE;\n\nvar Message = require('./message');\n\nvar IncomingMessageStream = require('./incoming-message-stream');\n\nvar OutgoingMessageStream = require('./outgoing-message-stream');\n\nmodule.exports = function (_EventEmitter) {\n  (0, _inherits3.default)(MessageIO, _EventEmitter);\n\n  function MessageIO(socket, packetSize, debug) {\n    (0, _classCallCheck3.default)(this, MessageIO);\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (MessageIO.__proto__ || (0, _getPrototypeOf2.default)(MessageIO)).call(this));\n\n    _this.socket = socket;\n    _this.debug = debug;\n    _this.tlsNegotiationComplete = false;\n    _this.incomingMessageStream = new IncomingMessageStream(_this.debug);\n\n    _this.incomingMessageStream.on('data', function (message) {\n      message.on('data', function (chunk) {\n        _this.emit('data', chunk);\n      });\n      message.on('end', function () {\n        _this.emit('message');\n      });\n    });\n\n    _this.outgoingMessageStream = new OutgoingMessageStream(_this.debug, {\n      packetSize: packetSize\n    });\n\n    _this.socket.pipe(_this.incomingMessageStream);\n\n    _this.outgoingMessageStream.pipe(_this.socket);\n\n    return _this;\n  }\n\n  (0, _createClass3.default)(MessageIO, [{\n    key: 'packetSize',\n    value: function packetSize() {\n      if (arguments.length > 0) {\n        var packetSize = arguments.length <= 0 ? undefined : arguments[0];\n        this.debug.log('Packet size changed from ' + this.outgoingMessageStream.packetSize + ' to ' + packetSize);\n        this.outgoingMessageStream.packetSize = packetSize;\n      }\n\n      return this.outgoingMessageStream.packetSize;\n    }\n  }, {\n    key: 'startTls',\n    value: function startTls(credentialsDetails, hostname, trustServerCertificate) {\n      var _this2 = this;\n\n      var credentials = tls.createSecureContext ? tls.createSecureContext(credentialsDetails) : crypto.createCredentials(credentialsDetails);\n      var duplexpair = new DuplexPair();\n      var securePair = this.securePair = {\n        cleartext: tls.connect({\n          socket: duplexpair.socket1,\n          servername: hostname,\n          secureContext: credentials,\n          rejectUnauthorized: !trustServerCertificate\n        }),\n        encrypted: duplexpair.socket2\n      }; // If an error happens in the TLS layer, there is nothing we can do about it.\n      // Forward the error to the socket so the connection gets properly cleaned up.\n\n      securePair.cleartext.on('error', function (err) {\n        // Streams in node.js versions before 8.0.0 don't support `.destroy`\n        if (typeof securePair.encrypted.destroy === 'function') {\n          securePair.encrypted.destroy();\n        }\n\n        _this2.socket.destroy(err);\n      });\n      securePair.cleartext.on('secureConnect', function () {\n        var cipher = securePair.cleartext.getCipher();\n\n        if (cipher) {\n          _this2.debug.log('TLS negotiated (' + cipher.name + ', ' + cipher.version + ')');\n        }\n\n        _this2.emit('secure', securePair.cleartext);\n\n        _this2.encryptAllFutureTraffic();\n      });\n      securePair.encrypted.on('data', function (data) {\n        _this2.sendMessage(TYPE.PRELOGIN, data, false);\n      });\n    }\n  }, {\n    key: 'encryptAllFutureTraffic',\n    value: function encryptAllFutureTraffic() {\n      this.securePair.encrypted.removeAllListeners('data');\n      this.outgoingMessageStream.unpipe(this.socket);\n      this.socket.unpipe(this.incomingMessageStream);\n      this.socket.pipe(this.securePair.encrypted);\n      this.securePair.encrypted.pipe(this.socket);\n      this.securePair.cleartext.pipe(this.incomingMessageStream);\n      this.outgoingMessageStream.pipe(this.securePair.cleartext);\n      this.tlsNegotiationComplete = true;\n    }\n  }, {\n    key: 'tlsHandshakeData',\n    value: function tlsHandshakeData(data) {\n      this.securePair.encrypted.write(data);\n    } // TODO listen for 'drain' event when socket.write returns false.\n    // TODO implement incomplete request cancelation (2.2.1.6)\n\n  }, {\n    key: 'sendMessage',\n    value: function sendMessage(packetType, data, resetConnection) {\n      var message = new Message({\n        type: packetType,\n        resetConnection: resetConnection\n      });\n      message.end(data);\n      this.outgoingMessageStream.write(message);\n    } // Temporarily suspends the flow of incoming packets.\n\n  }, {\n    key: 'pause',\n    value: function pause() {\n      this.incomingMessageStream.pause();\n    } // Resumes the flow of incoming packets.\n\n  }, {\n    key: 'resume',\n    value: function resume() {\n      this.incomingMessageStream.resume();\n    }\n  }]);\n  return MessageIO;\n}(EventEmitter);","map":null,"metadata":{},"sourceType":"script"}