{"ast":null,"code":"'use strict';\n\nvar _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar StreamParser = require('./stream-parser');\n/*\n  Buffers are thrown at the parser (by calling addBuffer).\n  Tokens are parsed from the buffer until there are no more tokens in\n  the buffer, or there is just a partial token left.\n  If there is a partial token left over, then it is kept until another\n  buffer is added, which should contain the remainder of the partial\n  token, along with (perhaps) more tokens.\n  The partial token and the new buffer are concatenated, and the token\n  parsing resumes.\n */\n\n\nvar Parser = function (_EventEmitter) {\n  (0, _inherits3.default)(Parser, _EventEmitter);\n\n  function Parser(debug, colMetadata, options) {\n    (0, _classCallCheck3.default)(this, Parser);\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (Parser.__proto__ || (0, _getPrototypeOf2.default)(Parser)).call(this));\n\n    _this.debug = debug;\n    _this.colMetadata = _this.colMetadata;\n    _this.options = options;\n    _this.parser = new StreamParser(_this.debug, _this.colMetadata, _this.options);\n\n    _this.parser.on('data', function (token) {\n      if (token.event) {\n        _this.emit(token.event, token);\n      }\n    });\n\n    _this.parser.on('drain', function () {\n      _this.emit('drain');\n    });\n\n    return _this;\n  } // Returns false to apply backpressure.\n\n\n  (0, _createClass3.default)(Parser, [{\n    key: 'addBuffer',\n    value: function addBuffer(buffer) {\n      return this.parser.write(buffer);\n    } // Writes an end-of-message (EOM) marker into the parser transform input\n    // queue. StreamParser will emit a 'data' event with an 'endOfMessage'\n    // pseudo token when the EOM marker has passed through the transform stream.\n    // Returns false to apply backpressure.\n\n  }, {\n    key: 'addEndOfMessageMarker',\n    value: function addEndOfMessageMarker() {\n      return this.parser.write(this.parser.endOfMessageMarker);\n    }\n  }, {\n    key: 'isEnd',\n    value: function isEnd() {\n      return this.parser.buffer.length === this.parser.position;\n    } // Temporarily suspends the token stream parser transform from emitting events.\n\n  }, {\n    key: 'pause',\n    value: function pause() {\n      this.parser.pause();\n    } // Resumes the token stream parser transform.\n\n  }, {\n    key: 'resume',\n    value: function resume() {\n      this.parser.resume();\n    }\n  }]);\n  return Parser;\n}(EventEmitter);\n\nmodule.exports.Parser = Parser;","map":null,"metadata":{},"sourceType":"script"}